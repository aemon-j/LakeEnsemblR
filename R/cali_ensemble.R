#' Calibrate models
#' 
#' Use one of three methods to calibrate specified models.
#'
#' @param config_file filepath; to LakeEnsemblr yaml master config file
#' @param num integer; the number of random parameter sets to generate. If param file is provided
#' num = number of parameters in that file.
#' @param param_file filepath; to previously created parameter file set. If NULL creates a new
#' parameter set. Defaults to NULL
#' @param cmethod character; Method for calibration. Can be "LHC", "MCMC" or "". Defaults to "LHC"
#' @param config_file filepath; to LakeEnsemblr yaml master config file
#' @param model vector; model to export driving data. Options include c("GOTM", "GLM", "Simstrat",
#' "FLake", "MyLake")
#' @param folder filepath; to folder which contains the model folders generated by export_config()
#' @param folder filepath; to folder which contains the model folders generated by export_config()
#' @param spin_up numeric; Number of days to disregard as spin-up for analysis.
#' @param out_f character; name of the folder to store results into
#' @param qualfun function; function that calculates measure of fit from observed and simulated 
#'    variables, takes the two arguments Observed and Simulated
#' @param nout_fun integer; number of return values from qualfun
#' @param parallel Boolean; should the model calibration be parallelized
#' @param job_name character; optional name to use as an RStudio job and as output variable
#'  name. It has to be a syntactically valid name. Check out thos webpage for more info on jobs: https://blog.rstudio.com/2019/03/14/rstudio-1-2-jobs/
#' @param ... additional arguments passed to modFit or modMCMC. Only used when method is
#'    modFit or MCMC
#' @details Parallelization is done using the `parallel` package and `parLapply()`. The number of
#'    cores used is set to the number of available cores minus one.
#'
#' @examples
#' \dontrun{
#' 
#' config_file <- 'LakeEnsemblR.yaml'
#' 
#' # LHC method
#' cali_ensemble(config_file = config_file, num = 200, cmethod = "LHC",
#'              model = c("FLake", "GLM", "GOTM", "Simstrat", "MyLake"))
#' 
#' # MCMC method                           
#' resMCMC <- cali_ensemble(config_file = config_file, num = 200, cmethod = "MCMC",
#'                          model = c("FLake", "GLM", "GOTM", "Simstrat", "MyLake"))
#' 
#' # modFit method using the Nelder-Mead algorithm      
#' resMmodFit <- cali_ensemble(config_file = config_file, num = 200, cmethod = "modFit",
#'                             model = c("FLake", "GLM", "GOTM", "Simstrat", "MyLake"),
#'                             method = "Nelder-Mead")
#'
#' # LHC method using multiple cores
#' cali_ensemble(config_file = config_file, num = 200, cmethod = "LHC",
#'              model = c("FLake", "GLM", "GOTM", "Simstrat", "MyLake"),
#'              parallel = TRUE)
#'              
#' # LHC method deployed as a job
#' cali_ensemble(config_file = config_file, num = 200, cmethod = "LHC",
#'              model = c("FLake", "GLM", "GOTM", "Simstrat", "MyLake"),
#'              job_name = "test")
#' test # View output from job                                        
#'              
#' }
#' @importFrom reshape2 dcast
#' @importFrom parallel detectCores
#' @importFrom parallel parLapply
#' @importFrom parallel clusterExport
#' @importFrom parallel makeCluster
#' @importFrom parallel stopCluster
#' @importFrom parallel clusterEvalQ
#' @importFrom FME Latinhyper
#' @importFrom FME modMCMC
#' @importFrom gotmtools get_yaml_value calc_cc input_nml sum_stat input_yaml get_vari
#' @importFrom glmtools get_nml_value
#' @importFrom reshape2 dcast
#' @importFrom FLakeR run_flake
#' @importFrom GLM3r run_glm
#' @importFrom GOTMr run_gotm
#' @importFrom SimstratR run_simstrat
#' @importFrom MyLakeR run_mylake
#' @importFrom lubridate round_date seconds_to_period
#' @importFrom configr read.config
#'
#' @export

cali_ensemble <- function(config_file, num = NULL, param_file = NULL, cmethod = "LHC",
                          qualfun = qual_fun, parallel = FALSE, job_name,
                          model = c("FLake", "GLM", "GOTM", "Simstrat", "MyLake"),
                          folder = ".", spin_up = NULL, out_f = "cali", nout_fun = 5, ...) {
  
  # ---- Send to RStudio Jobs -----
  if (!missing(job_name)) {
    if (make.names(job_name) != job_name) {
      stop("job_name '",
           job_name,
           "' is not a syntactically valid variable name.")
    }
    
    # Evaluates all arguments.
    call <- match.call()
    call$config_file <- config_file
    call$num <- num
    call$param_file <- param_file
    call$cmethod <- cmethod
    # call$qualfun <- qualfun
    call$parallel <- parallel
    call$model <- model
    call$folder <- folder
    call$spin_up <- spin_up
    call$out_f <- out_f
    call$nout_fun <- nout_fun
    
    
    
    call_list <- lapply(call, eval)
    call[names(call_list)[-1]] <- call_list[-1]
    
    script <- make_script(call = call, name = job_name)
    if (!requireNamespace("rstudioapi", quietly = TRUE)) {
      stop("Jobs are only supported in RStudio.")
    }
    
    if (!rstudioapi::isAvailable("1.2")) {
      stop(
        "Need at least version 1.2 of RStudio to use jobs. Currently running ",
        rstudioapi::versionInfo()$version,
        "."
      )
    }
    
    job <-
      rstudioapi::jobRunScript(path = script,
                               name = job_name,
                               exportEnv = "R_GlobalEnv")
    return(invisible(job))
  }
#######

##----------------- check inputs and set things up -------------------------------------------------  
  
  # check if method is one of the allowed
  if(!cmethod %in% c("modFit", "LHC", "MCMC")) {
    stop(paste0("Method ", cmethod, " not allowed. Use one of: modFit, LHC, or MCMC"))
  }
  
  # check model input
  model <- check_models(model)
  # check the master config file
  check_master_config(config_file, model)
  
  # It"s advisable to set timezone to GMT in order to avoid errors when reading time
  original_tz <- Sys.getenv("TZ")
  Sys.setenv(TZ = "GMT")
  tz <- "UTC"
  
  # Set working directory
  oldwd <- getwd()
  
  # this way if the function exits for any reason, success or failure, these are reset:
  on.exit({
    setwd(oldwd)
    Sys.setenv(TZ = original_tz)
  })
  
  
  # path to master config file
  yaml <- file.path(folder, config_file)
  # get setup parameter
  lat <- get_yaml_value(file = yaml, label = "location", key = "latitude")
  start <- get_yaml_value(file = yaml, label = "time", key = "start")
  stop <- get_yaml_value(file = yaml, label = "location", key = "stop")
  meteo_file <- get_yaml_value(file = yaml, label = "meteo", key = "file")
  obs_file <- get_yaml_value(file = yaml, label = "temperature", key = "file")
  time_unit <- get_yaml_value(config_file, "output", "time_unit")
  time_step <- get_yaml_value(config_file, "output", "time_step")
  cnfg_l <- lapply(model, function(m) get_yaml_value(config_file, "config_files", m))
  names(cnfg_l) <- model
  met_timestep <- get_meteo_time_step(file.path(folder,
                                                get_yaml_value(config_file, "meteo", "file")))
 
##----------------- read in observed data  ---------------------------------------------------------  
 
  # Create output time vector
  if(is.null(spin_up)){
    out_time <- seq.POSIXt(as.POSIXct(start, tz = tz), as.POSIXct(stop, tz = tz), by =
                             paste(time_step, time_unit))
  }else{
    start <- as.POSIXct(start, tz = tz) + spin_up * 24 * 60 * 60
    stop <- as.POSIXct(stop, tz = tz)
    out_time <- seq.POSIXt(as.POSIXct(start, tz = tz), as.POSIXct(stop, tz = tz), by =
                             paste(time_step, time_unit))
  }
  out_time <- data.frame(datetime = out_time)
  
  if(met_timestep == 86400){
    out_hour <- hour(start)
  }else{
    out_hour <- 0
  }
  
  # read in Observed data
  message("Loading observed wtemp data...")
  obs <- read.csv(file.path(folder, obs_file), stringsAsFactors = FALSE)
  obs$datetime <- as.POSIXct(obs$datetime, tz = tz)
  
  # Susbet to out_time
  obs <- obs[obs$datetime %in% out_time$datetime, ]
  
  obs_deps <- unique(obs$Depth_meter)
  
  # change data format from long to wide
  obs_out <- dcast(obs, datetime ~ Depth_meter, value.var = "Water_Temperature_celsius")
  str_depths <- colnames(obs_out)[2:ncol(obs_out)]
  colnames(obs_out) <- c("datetime", paste("wtr_", str_depths, sep = ""))
  obs_out$datetime <- as.POSIXct(obs_out$datetime)
  message("Finished!")
  
##---------------- read in  parameter initial values or create parameter sets ----------------------
  
  # if not existing create output file
  dir.create(file.path(folder, out_f), showWarnings = FALSE)

  ## use initial values from master config file as starting values
  # load master config file
  configr_master_config <- configr::read.config(file.path(folder, config_file))
  # meteo parameter
  cal_section <- configr_master_config[["calibration"]][["met"]]
  params_met <- sapply(names(cal_section), function(n)cal_section[[n]]$initial)
  p_lower_met <- sapply(names(cal_section), function(n)cal_section[[n]]$lower)
  p_upper_met <- sapply(names(cal_section), function(n)cal_section[[n]]$upper)
  # get names of models for which parameter are given
  model_p <- model[model %in% names(configr_master_config[["calibration"]])]
  # model specific parameters
  cal_section <- lapply(model_p, function(m)configr_master_config[["calibration"]][[m]])
  names(cal_section) <- model_p
  # get parameters 
  params_mod <- lapply(model_p, function(m) {
                  sapply(names(cal_section[[m]]),
                         function(n) as.numeric(cal_section[[m]][[n]]$initial))})
  names(params_mod) <- model_p
  # get lower bound
  p_lower_mod <- lapply(model_p, function(m) {
    sapply(names(cal_section[[m]]),
           function(n) as.numeric(cal_section[[m]][[n]]$lower))})
  names(p_lower_mod) <- model_p
  # get upper bound
  p_upper_mod <- lapply(model_p, function(m) {
    sapply(names(cal_section[[m]]),
           function(n) as.numeric(cal_section[[m]][[n]]$upper))})
  names(p_upper_mod) <- model_p
  # log transform for LHC?
  log_mod <- lapply(model_p, function(m) {
    sapply(names(cal_section[[m]]),
           function(n) as.logical(cal_section[[m]][[n]]$log))})
  names(log_mod) <- model_p
  
  # create a list with parameters for every model
  pars_l <- lapply(model, function(m){
    df <- data.frame(pars = c(params_met, params_mod[[m]]),
                     name = c(names(params_met), names(params_mod[[m]])),
                     upper = c(p_upper_met, p_upper_mod[[m]]),
                     lower = c(p_lower_met, p_lower_mod[[m]]),
                     type = c(rep("met", length(params_met)),
                              rep("model", length(params_mod[[m]]))),
                     log = c(rep(FALSE, length(params_met)), log_mod[[m]]),
                     stringsAsFactors = FALSE)
    colnames(df) <- c("pars", "name", "upper", "lower", "type", "log")
    return(df)
  })
  names(pars_l) <- model
  
  # count number of different sets for LHC
  par_sets <- setNames(sapply(model, function(m) length(pars_l[[m]]$pars)), model)
  # output name
  outf_n <- paste0(cmethod, "_", format(Sys.time(), "%Y%m%d%H%M"))
  
  # if cmethod == LHC sample parameter or read from provided file
  if(cmethod == "LHC") {
    
    # name for the output files
    if(is.null(param_file)) {
    } else {
      # if the models have different number of pars to calibrate a file can not be supplied
      if(length(unique(par_sets)) > 1) {
        stop(paste0("The calibration configuration in the master config file ",
                    config_file, "results in ", length(unique(par_sets)),
                    " In this case providing own calibration file is not supported."))
      }
      # set name to name of supplied file
      outf_n <- gsub("_params_", "", basename(param_file))
    }
    
    if(is.null(param_file)) {
      pars_lhc <- list()
      for (m in model) {
        # range of parametes
        prange <- matrix(c(pars_l[[m]]$lower, pars_l[[m]]$upper),ncol = 2)
        # calculate log if wanted
        prange[pars_l[[m]]$log, ] <- log10(prange[pars_l[[m]]$log, ])
        # sample parameter sets
        pars_lhc[[m]] <- Latinhyper(parRange = prange, num = num)
        # retransform log parameter
        pars_lhc[[m]][, pars_l[[m]]$log] <- 10^pars_lhc[[m]][, pars_l[[m]]$log]
        # only use 5 significant digits
        pars_lhc[[m]] <- signif(pars_lhc[[m]], 5)
        # set colnames
        colnames(pars_lhc[[m]]) <- pars_l[[m]]$name
        pars_lhc[[m]] <- as.data.frame(pars_lhc[[m]])
        # add identifier for every set
        pars_lhc[[m]]$par_id <- paste0("p", formatC(seq_len(num), width = round(log10(num))+1,
                                                    format = "d", flag = "0"))
        # write parameter sets to file
        write.table(pars_lhc[[m]], file = file.path(folder, out_f,
                                                    paste0("params_", m, "_", outf_n, ".csv")),
                    quote = FALSE, row.names = FALSE, sep = ",")
        
      }
      
    } else {
      # if file is supplied read it in
      pars_lhc <- lapply(model, function(m) read.csv(param_file, stringsAsFactors = FALSE))
      names(pars_lhc) <- model
      # check if the number of columns in the file fit the number of parameters to be calibrated
      if((ncol(pars_lhc[[1]])-1) != unique(par_sets)) {
        stop(paste0("Number of parameters in file ", param_file, " (", (ncol(pars_lhc[[1]])-1),
                    ") ", "and number of parameters to calibrate in master config file (",
                    unique(par_sets), ") do not match!"))
      }
      num <- nrow(pars_lhc[[1]])
    }
  } else {
    # we just nedd a empty variable to export to parallel clusters (not a good fix, but works)
    pars_lhc <- NULL
  }

##--------- prepare models to be run ---------------------------------------------------------------  

  # prepare controll files of the models
  export_config(config_file = config_file, model = model, folder = folder)
  # prepare meteo files for the models
  export_meteo(config_file = config_file,model =  model,meteo_file =  meteo_file, folder = folder)
  # export initial conditions for each model
  export_init_cond(config_file = config_file, 
                   model = model,
                   print = TRUE)
  
##----------------- read in model meteo files ------------------------------------------------------
  
  ## read in meteo
  met_l <- lapply(model, function(m){
    met_name <- get_model_met_name(m, cnfg_l[[m]])
    ## list with long standard names
    l_names <- as.list(met_var_dic$standard_name)
    names(l_names) <- met_var_dic$short_name
    
    if(m == "MyLake") {
      met_m <- read.table(file.path(folder, m, met_name), sep = "\t",
                        header = FALSE)
      colnames(met_m) <- c(l_names$time, l_names$swr, l_names$cc, l_names$airt, l_names$relh,
                           l_names$p_surf, l_names$wind_speed, l_names$precip)
    } else if (m == "GLM") {
      met_m <- read.table(file.path(folder, m, met_name), sep = ",", header = TRUE)
    } else if (m == "FLake") {
      # read in meteo file
      met_m <- read.table(file.path(folder, m, met_name), sep = "\t",
                              header = FALSE)
      colnames(met_m) <- c("!Shortwave_Radiation_Downwelling_wattPerMeterSquared",
                           "Air_Temperature_celsius", "Vapor_Pressure_milliBar",
                           "Ten_Meter_Elevation_Wind_Speed_meterPerSecond",
                           "Cloud_Cover_decimalFraction", "datetime")
    } else if (m == "GOTM") {
      # read in meteo file
      met_m <- read.table(file.path(folder, m, met_name), sep = "\t", header = TRUE)
      colnames(met_m)[1] <- "!datetime"
    } else if(m == "Simstrat") {
      # read in meteo file
      met_m <- read.table(file.path(folder, m, met_name), sep = "\t",
                                 header = TRUE)
      
    }
    return(met_m)
  })

  names(met_l) <- model

##------------------------- parallel LCH calibration -----------------------------------------------

  if(parallel){
    ncores <- detectCores() -1
    clust <- makeCluster(ncores)
    clusterExport(clust, varlist = list("pars_lhc", "pars_l", "model", "config_file", "met_l",
                                        "folder", "out_f", "cnfg_l", "obs_deps",
                                        "obs_out", "out_hour", "qualfun",
                                        "outf_n"),
                  envir = environment())
    clusterEvalQ(clust, library(LakeEnsemblR))
    if(cmethod == "LHC") {
      message("\nStarted parallel LHC\n")
      model_out <- setNames(
        parLapply(clust, model, function(m) LHC_model(pars = pars_lhc[[m]],
                                                      type = pars_l[[m]]$type,
                                                      model = m, var = "temp",
                                                      config_file = config_file,
                                                      met = met_l[[m]], folder = folder,
                                                      out_f = out_f, config_f = cnfg_l[[m]],
                                                      obs_deps = obs_deps, obs_out = obs_out,
                                                      out_hour = out_hour, qualfun = qualfun,
                                                      nout_fun = 5, outf_n = outf_n
        )),
        model
      )
      message("\nFinished parallel LHC\n")
    }
##------------------------- parallel MCMC calibration ----------------------------------------------
    
    if(cmethod == "MCMC") {
      message("\nStarted parallel MCMC\n")
      model_out <- setNames(
        parLapply(clust, model, function(m){
          FME::modMCMC(f = wrap_model,
                       p = setNames(pars_l[[m]]$pars,
                                    pars_l[[m]]$name), 
                       type = pars_l[[m]]$type,
                       model = m,
                       var = "temp",
                       config_file = config_file,
                       met = met_l[[m]],
                       folder = folder,
                       config_f = cnfg_l[[m]],
                       out_f = out_f,  obs_deps = obs_deps, obs_out = obs_out,
                       out_hour = out_hour,
                       qualfun = function(O, P){
                         ssr = sum((as.matrix(O[, -1]) - as.matrix(P[, -1]))^2, na.rm = TRUE)},
                       outf_n = outf_n,
                       niter = num, ...)}),
        model
      )
      message("\nFinished parallel MCMC\n")
    }
    
##------------------------- parallel modFit calibration ----------------------------------------------
    if(cmethod == "modFit") {
      message("\nStarted parallel modFit\n")
      model_out <- setNames(
        parLapply(clust, model, function(m){
          FME::modFit(f = wrap_model,
                      p = setNames(pars_l[[m]]$pars,
                                   pars_l[[m]]$name), 
                      type = pars_l[[m]]$type,
                      model = m,
                      var = "temp",
                      config_file = config_file,
                      met = met_l[[m]],
                      folder = folder,
                      config_f = cnfg_l[[m]],
                      out_f = out_f,  obs_deps = obs_deps, obs_out = obs_out,
                      out_hour = out_hour,
                      qualfun = function(O, P){
                        res = na.exclude(as.vector(as.matrix(O[, -1]) - as.matrix(P[, -1])))},
                      outf_n = "",
                      write = FALSE,
                      lower = setNames(pars_l[[m]]$lower,
                                       pars_l[[m]]$name),
                      upper = setNames(pars_l[[m]]$upper,
                                       pars_l[[m]]$name),
                      ...)}),
        model
      )
      message("\nFinished parallel modFit\n")
    }
    # stop cluster  
    stopCluster(clust)
  } else {
    
##------------------------- LCH calibration --------------------------------------------------------
    
    if(cmethod == "LHC") {
      model_out <- setNames(
        lapply(model, function(m) LHC_model(pars = pars_lhc[[m]],
                                            type = pars_l[[m]]$type,
                                            model = m, var = "temp",
                                            config_file = config_file,
                                            met = met_l[[m]], folder = folder,
                                            out_f = out_f, config_f = cnfg_l[[m]],
                                            obs_deps = obs_deps, obs_out = obs_out,
                                            out_hour = out_hour, qualfun = qualfun,
                                            nout_fun = 5, outf_n = outf_n
                                                  )),
        model
      )
    }
 
##------------------------- MCMC calibration -------------------------------------------------------
    
    if(cmethod == "MCMC") {
      model_out <- setNames(
                  lapply(model, function(m){
                    message(paste0("\nStrated MCMC for model ", m, "\n"))
                      res <- FME::modMCMC(f = wrap_model,
                                          p = setNames(pars_l[[m]]$pars,
                                                       pars_l[[m]]$name), 
                                          type = pars_l[[m]]$type,
                                          model = m,
                                          var = "temp",
                                          config_file = config_file,
                                          met = met_l[[m]],
                                          folder = folder,
                                          config_f = cnfg_l[[m]],
                                          out_f = out_f,  obs_deps = obs_deps, obs_out = obs_out,
                                          out_hour = out_hour,
                                          qualfun = function(O, P){
                                           ssr = sum((as.matrix(O[, -1]) - as.matrix(P[, -1]))^2,
                                                     na.rm = TRUE)},
                                          outf_n = outf_n,
                                          niter = num, ...)
                      message(paste0("\nFinished MCMC for model ", m, "\n"))
                      return(res)}),
                  model
      )
    }
  
##------------------------- modFit calibration -------------------------------------------------------
    
    if(cmethod == "modFit") {
      model_out <- setNames(
        lapply(model, function(m){
          message(paste0("\nStrated fitting of model ", m, "\n"))
          res <- FME::modFit(f = wrap_model,
                             p = setNames(pars_l[[m]]$pars,
                                   pars_l[[m]]$name),
                             type = pars_l[[m]]$type,
                             model = m,
                             var = "temp",
                             config_file = config_file,
                             met = met_l[[m]],
                             folder = folder,
                             config_f = cnfg_l[[m]],
                             out_f = out_f,  obs_deps = obs_deps, obs_out = obs_out,
                             out_hour = out_hour,
                             qualfun = function(O, P){
                             res = na.exclude(as.vector(as.matrix(O[, -1]) - as.matrix(P[, -1])))},
                             outf_n = "",
                             write = FALSE,
                             lower = setNames(pars_l[[m]]$lower,
                                              pars_l[[m]]$name),
                             upper = setNames(pars_l[[m]]$upper,
                                              pars_l[[m]]$name),
                             ...)
          message(paste0("\nFinished fitting of model ", m, "\n"))
          return(res)}),
        model
      )
    }
  }
  # return calibration results
  return(model_out)
}

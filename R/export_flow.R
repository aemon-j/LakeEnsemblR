#' Export LakeEnsemblR standardised flow files to model specific driver format
#'
#' Export in- anbd out-flow driver files for each model
#'
#' @param config_file filepath; to LakeEnsemblr yaml master config file
#' @param model vector; model to export driving data. Options include
#'    c("GOTM", "GLM", "Simstrat", "FLake", "MyLake")
#' @param folder filepath; to folder which contains the model folders generated by export_config()
#'
#' @examples
#' \dontrun{
#' export_inflow(config_file, model = c("GOTM", "GLM", "Simstrat", "FLake", "MyLake"))
#' }
#' @importFrom gotmtools get_yaml_value calc_cc input_yaml
#' @importFrom glmtools read_nml set_nml write_nml
#'
#' @export
export_inflow <- function(config_file, model = c("GOTM", "GLM", "Simstrat", "FLake", "MyLake"),
                          folder = "."){

  # It's advisable to set timezone to GMT in order to avoid errors when reading time
  original_tz  <-  Sys.getenv("TZ")
  Sys.setenv(TZ = "UTC")

  # Set working directory
  oldwd <- getwd()
  setwd(folder)
  
  # this way if the function exits for any reason, success or failure, these are reset:
  on.exit({
    setwd(oldwd)
    Sys.setenv(TZ = original_tz)
  })

  # check model input
  model <- check_models(model)

##-------------Read settings---------------
  # initial water level
  init_lvl <- get_yaml_value(config_file, "location", "init_depth")
  # surface elevation
  surf_lvl <- get_yaml_value(config_file, "location", "elevation")
  # bottom elevation
  bot_lvl <- surf_lvl - get_yaml_value(config_file, "location", "depth")
  
  # Use inflows
  use_inflows <- get_yaml_value(config_file, "inflows", "use")
  # Use outflows
  use_outflows <- get_yaml_value(config_file, "outflows", "use")
  if(!use_outflows) {
    # Use counter outflows
    use_c_outflows <- get_yaml_value(config_file, "inflows", "mass-balance")
    num_outflows <- 0
  } else {
    use_c_outflows <- FALSE
    # number of outflows
    num_outflows <- get_yaml_value(config_file, "outflows", "number_outflows")
    # outflow depths
    lvl_outflows <- get_yaml_value(config_file, "outflows", "outflow_lvl")
    # Get scaling parameter
    scale_param_out <- get_yaml_value(config_file, "outflows", "scale_param")
  }

  # Get start & stop dates
  start_date <- get_yaml_value(config_file, "time", "start")
  stop_date <- get_yaml_value(config_file, "time", "stop")
  
  if(use_inflows) {
    # Get scaling parameter
    scale_param_inf <- get_yaml_value(config_file, "inflows", "scale_param")
    # number of inflows
    num_inflows <- get_yaml_value(config_file, "inflows", "number_inflows")
  }


##---------------FLake-------------

  if("FLake" %in% model){
    fla_fil <- file.path(folder, get_yaml_value(config_file, "config_files", "FLake"))

    if(!use_inflows){
      input_nml(fla_fil, label = "inflow", key = "Qfromfile",  ".false.")
    }else{
      input_nml(fla_fil, label = "inflow", key = "Qfromfile",  ".true.")
    }
  }

##---------------GLM-------------

  if("GLM" %in% model){
    glm_nml <- file.path(folder, get_yaml_value(config_file, "config_files", "GLM"))

    # Read in nml and input parameters
    nml <- read_nml(glm_nml)
    # if no inflow or outflow is used  this list is keep otherwise it is changed
    inp_list <- list("num_inflows" = 0, "num_outlet" = 0)
    # set inflow
    if (use_inflows) {
      inp_list$num_inflows  <-  num_inflows
      inp_list <- c(inp_list, list("names_of_strms" = paste0("inflow_", 1:num_inflows),
                                   "strm_hf_angle" = rep(65, num_inflows),
                                   "strmbd_slope" = rep(2, num_inflows),
                                   "strmbd_drag" = rep(0.016, num_inflows),
                                   "inflow_factor"= rep(1, num_inflows),
                                   "inflow_fl" = paste0("inflow_", 1:num_inflows,".csv")))
    }
    # if used set inflow balancing outflow
    if (use_c_outflows) {
      max_elv <- get_nml_value(nml, "H")
      inp_list$num_outlet <- 1
      inp_list <- c(inp_list, list("outflow_fl" = "outflow.csv",
                                   "outl_elvs" = max(max_elv)))
    }
    # set outflows
    if (use_outflows){
      outf_surf <- rep(FALSE, num_outflows)
      outf_surf[lvl_outflows == -1] <- TRUE
      #!! outflow elevations need to be in meters above sea level!!
      lvl_outflows_glm <- lvl_outflows + bot_lvl
      # outflow lvl for floating outflows is set to 0
      lvl_outflows_glm[lvl_outflows == -1] <- 0
      inp_list$num_outlet <- num_outflows
      inp_list <- c(inp_list, list("flt_off_sw" = outf_surf,
                                   "outl_elvs" = lvl_outflows_glm,
                                   "outflow_fl" = paste0("outflow_", 1:num_outflows, ".csv"),
                                   "outflow_factor" = rep(1, num_outflows)))
    }

    nml <- glmtools::set_nml(nml, arg_list = inp_list)
    write_nml(nml, glm_nml)

  }

##---------------GOTM-------------

  if("GOTM" %in% model){
    got_yaml <- file.path(folder, get_yaml_value(config_file, "config_files", "GOTM"))
    yml_no_comment <- unname(sapply(readLines(got_yaml), function(x) strsplit(x, "#")[[1]][1]))
    # number of inflows in the yaml file so far
    num_inf_yaml <- length(grep("inflow\\_*\\d*:", yml_no_comment, value = TRUE))

    # number of outflows in the yaml file so far
    num_outf_yaml <- length(grep("outflow\\_*\\d*:", yml_no_comment, value = TRUE))
      
      
    ## Switch off streams
    if(!use_inflows){
      # remove all inflows but one
      if (num_inf_yaml > 1) {
        for (i in 2:(num_inf_yaml + 1)) {
          rm_yaml_sec(got_yaml, paste0("inflow_", i))
        }
      }
      # streams_switch(file = got_yaml, method = "off")
      input_yaml_multiple(got_yaml, key1 = "streams", key2 = "inflow", key3 = "flow", key4 =
                            "method", value = 0)
      input_yaml_multiple(got_yaml, key1 = "streams", key2 = "inflow", key3 = "temp", key4 =
                            "method", value = 0)
      input_yaml_multiple(got_yaml, key1 = "streams", key2 = "inflow", key3 = "salt", key4 =
                            "method", value = 0)
    }
    if (!use_outflows) {
      # remove all outflows but one
      if (num_outf_yaml > 1) {
        for (i in 2:(num_outf_yaml + 1)) {
          rm_yaml_sec(got_yaml, paste0("outflow_", i))
        }
      }
      input_yaml_multiple(got_yaml, key1 = "streams", key2 = "outflow", key3 = "flow", key4 =
                            "method", value = 0)
      input_yaml_multiple(got_yaml, key1 = "streams", key2 = "outflow", key3 = "temp", key4 =
                            "method", value = 0)
      input_yaml_multiple(got_yaml, key1 = "streams", key2 = "outflow", key3 = "salt", key4 =
                            "method", value = 0)
    }
    # set inflows
    if (use_inflows) {
      
      # add additional inflows if necessary
      if(num_inflows > 1) {
        for (i in num_inflows:2) {
          doubl_yaml_sec(got_yaml, "inflow", paste0("_", i)) 
        }
        
        # set inflow settings for all inflows
        for (i in 1:num_inflows) {
          
          if(i == 1) {
            inf_sec <- "inflow"
          } else {
            inf_sec <- paste0("inflow_", i)
          }
          
          # streams_switch(file = got_yaml, method = "on")
          input_yaml_multiple(got_yaml, key1 = "streams", key2 = inf_sec, key3 = "flow", key4 =
                                "method", value = 2)
          input_yaml_multiple(got_yaml, key1 = "streams", key2 = inf_sec, key3 = "temp", key4 =
                                "method", value = 2)
          input_yaml_multiple(got_yaml, key1 = "streams", key2 = inf_sec, key3 = "salt", key4 =
                                "method", value = 2)
          
        }
        
        
      }
    }
    # set water balance outflows
    if (use_c_outflows) {
      input_yaml_multiple(got_yaml, key1 = "streams", key2 = "outflow", key3 = "method",
                          value = 1)
      input_yaml_multiple(got_yaml, key1 = "streams", key2 = "outflow", key3 = "flow", key4 =
                            "method", value = 2)
      input_yaml_multiple(got_yaml, key1 = "streams", key2 = "outflow", key3 = "temp", key4 =
                            "method", value = 0)
      input_yaml_multiple(got_yaml, key1 = "streams", key2 = "outflow", key3 = "salt", key4 =
                            "method", value = 0)
    }

    # set outflows  
    if (use_outflows) {
      outf_surf <- rep(FALSE, num_outflows)
      outf_surf[lvl_outflows == -1] <- TRUE
      # outflow lvl in GOTM are meters below initial surface lvl
      lvl_outflows_gotm <- lvl_outflows - init_lvl
      # add additional outflows if necessary
      if(num_outflows > 1) {
        for (i in num_outflows:2) {
          doubl_yaml_sec(got_yaml, "outflow", paste0("_", i)) 
        }
        
        # set outflow settings for all outflows
        for (i in 1:num_outflows) {
          
          if(i == 1) {
            inf_sec <- "outflow"
          } else {
            inf_sec <- paste0("outflow_", i)
          }
          
          # streams_switch(file = got_yaml, method = "on")
          input_yaml_multiple(got_yaml, key1 = "streams", key2 = inf_sec, key3 = "flow", key4 =
                                "method", value = ifelse(outf_surf[i], 2, 3))
          input_yaml_multiple(got_yaml, key1 = "streams", key2 = inf_sec, key3 = "method",
                              value = 3)
          input_yaml_multiple(got_yaml, key1 = "streams", key2 = inf_sec, key3 = "zl",
                              value = lvl_outflows_gotm[i] - 0.5)
          input_yaml_multiple(got_yaml, key1 = "streams", key2 = inf_sec, key3 = "zu",
                              value = lvl_outflows_gotm[i] + 0.5)
          input_yaml_multiple(got_yaml, key1 = "streams", key2 = inf_sec, key3 = "temp", key4 =
                                "method", value = 0)
          input_yaml_multiple(got_yaml, key1 = "streams", key2 = inf_sec, key3 = "salt", key4 =
                                "method", value = 0)
          
        }
        
        
      }
    }
    

  }

##---------------Simstrat-------------

  if("Simstrat" %in% model){
    sim_par <- file.path(folder, get_yaml_value(config_file, "config_files", "Simstrat"))

    # Turn off inflow
    if(!use_inflows){
      ## Set Qin and Qout to 0 inflow
      inflow_line_1 <- "Time [d]\tQ_in [m3/s]"
      # In case Kw is a single value for the whole simulation:
      inflow_line_2 <- "1"
      inflow_line_3 <- "-1 0.00"
      start_sim <- get_json_value(sim_par, "Simulation", "Start d")
      end_sim <- get_json_value(sim_par, "Simulation", "End d")
      inflow_line_4 <- paste(start_sim, 0.000)
      inflow_line_5 <- paste(end_sim, 0.000)

      file_connection <- file("Simstrat/Qin.dat")
      writeLines(c(inflow_line_1, inflow_line_2, inflow_line_3, inflow_line_4, inflow_line_5),
                 file_connection)
      close(file_connection)
      file_connection <- file("Simstrat/Qout.dat")
      writeLines(c(inflow_line_1, inflow_line_2, inflow_line_3, inflow_line_4, inflow_line_5),
                 file_connection)
      close(file_connection)
    }else{
      inflow_line_1 <- "Time [d]\tQ_in [m3/s]"
      # In case Kw is a single value for the whole simulation:
      inflow_line_2 <- "1"
      inflow_line_3 <- "-1 0.00"
      start_sim <- get_json_value(sim_par, "Simulation", "Start d")
      end_sim <- get_json_value(sim_par, "Simulation", "End d")
      inflow_line_4 <- paste(start_sim, 0.000)
      inflow_line_5 <- paste(end_sim, 0.000)

      file_connection <- file("Simstrat/Qout.dat")
      writeLines(c(inflow_line_1, inflow_line_2, inflow_line_3, inflow_line_4, inflow_line_5),
                 file_connection)
      close(file_connection)
    }

  }

##---------------MyLake-------------

  if("MyLake" %in% model){
    # Load config file MyLake
    load(get_yaml_value(config_file, "config_files", "MyLake"))

    if(!use_inflows){
      mylake_config[["Inflw"]] <- matrix(rep(0, 8 * length(seq.POSIXt(from = as.POSIXct(start_date),
                                                                    to = as.POSIXct(stop_date),
                                                                    by = "day"))),
                                         ncol = 8)

      # save lake-specific config file for MyLake
      temp_fil <- gsub(".*/", "", get_yaml_value(config_file, "config_files", "MyLake"))
      save(mylake_config, file = file.path(folder, "MyLake", temp_fil))
    }
  }

##-------------If inflow == TRUE---------------

  if(use_inflows == TRUE){

    inflow_file <- get_yaml_value(file = config_file, label = "inflows", key = "file")
    # Check if file exists
    if(!file.exists(inflow_file)){
      stop(inflow_file, " does not exist. Check filepath in ", config_file)
    }

    ### Import data
    message("Loading inflow data...")
    inflow <- read.csv(file.path(folder, inflow_file), stringsAsFactors = FALSE)
    inflow[, 1] <- as.POSIXct(inflow[, 1])
    # Check time step
    tstep <- diff(as.numeric(inflow[, 1]))

    start_date <- get_yaml_value(config_file, "time", "start")
    # Stop date
    stop_date <- get_yaml_value(config_file, "time", "stop")

    inflow_start <- which(inflow$datetime == as.POSIXct(start_date))
    inflow_stop <- which(inflow$datetime == as.POSIXct(stop_date))

    inflow <- inflow[inflow_start:inflow_stop, ]

    ### Naming conventions standard input
    # remove numbers if multiple inflows are present
    cln_inf <- colnames(inflow)
    if(num_inflows > 1) {
      cln_inf <- gsub("(\\w+)\\_\\d+\\>", "\\1", cln_inf)
    }
    # test if names are right
    chck_inflow <- sapply(list(cln_inf), function(x) x %in% lake_var_dic$standard_name)
    if(any(!chck_inflow)){
      chck_inflow[which(chck_inflow == FALSE)] <- sapply(list(cln_inf[which(
        chck_inflow == FALSE)]), function(x) x %in% met_var_dic$standard_name)

      if(any(!chck_inflow)){
        stop("Colnames of inflow file are not in standard notation! ",
                    "They should be one of: \ndatetime\nFlow_metersCubedPerSecond\n",
                    "Water_Temperature_celsius\nSalinity_practicalSalinityUnits")
      }
    }
    
    ### Apply scaling
    if(num_inflows == 1) {
      inflow[["Flow_metersCubedPerSecond"]] <- inflow[["Flow_metersCubedPerSecond"]] *
        scale_param_inf
    } else if(num_inflows > 1) {
      for (i in 1:num_inflows) {
        inflow[[paste0("Flow_metersCubedPerSecond_", i)]] <-
          inflow[[paste0("Flow_metersCubedPerSecond_", i)]] * scale_param_inf[i]
      }
    }
    # if multiple inflows are present put them in a list
    if(num_inflows > 1) {
      inflow_ls <- list()
      for (i in 1:num_inflows) {
        inflow_ls[[paste0("inflow_", i)]] <-
          data.frame(datetime = inflow$datetime,
                     Flow_metersCubedPerSecond = inflow[[paste0("Flow_metersCubedPerSecond_", i)]],
                     Water_Temperature_celsius = inflow[[paste0("Water_Temperature_celsius_", i)]],
                     Salinity_practicalSalinityUnits =
                       inflow[[paste0("Salinity_practicalSalinityUnits_", i)]]
                     )
      }
      inflow <- inflow_ls
      rm(inflow_ls)
    }
    
    ##### FLake
    if("FLake" %in% model){

      if(num_inflows > 1) {
        # flake_inflow <- average inflows from list
      } else {
        flake_inflow <- inflow
      }
      flake_inflow <- format_inflow(inflow = flake_inflow, model = "FLake", config_file = config_file)

      flake_outfile <- "Tinflow"

      flake_outfpath <- file.path(folder, "FLake", flake_outfile)

      write.table(flake_inflow, flake_outfpath, quote = FALSE, row.names = FALSE, sep = "\t",
                  col.names = FALSE)


      temp_fil <- get_yaml_value(config_file, "config_files", "FLake")
      input_nml(temp_fil, label = "inflow", key = "time_step_number", nrow(flake_inflow))

      message("FLake: Created file ", file.path(folder, "FLake", flake_outfile))

      if(use_outflows){
        message("FLake does not need outflows, as mass fluxes are not considered.")
      }

    }

    ###### GLM
    if("GLM" %in% model){
      if(num_inflows == 1) {
        glm_inflow <- format_inflow(inflow = inflow, model = "GLM", config_file = config_file)
  
        inflow_outfile <- file.path("GLM", "inflow_1.csv")
        write.csv(glm_inflow, inflow_outfile, row.names = FALSE, quote = FALSE)
        message("GLM: Created file ", file.path(folder, "GLM", "inflow_file.csv"))
      } else if (num_inflows > 1) {
        for (i in 1:num_inflows) {
          glm_inflow <- format_inflow(inflow = inflow[[i]], model = "GLM",
                                      config_file = config_file)
          
          inflow_outfile <- file.path("GLM", paste0("inflow_", i, ".csv"))
          write.csv(glm_inflow, inflow_outfile, row.names = FALSE, quote = FALSE)
          message("GLM: Created file ", file.path(folder, "GLM", paste0("inflow_", i, ".csv")))
        }
      }

      if(use_c_outflows) {
        
        glm_outflow <- glm_inflow[, c("Time", "FLOW")]
        outflow_outfile <- file.path("GLM", "outflow.csv")
        write.csv(glm_outflow, outflow_outfile, row.names = FALSE, quote = FALSE)
        message("GLM: Created outflow file ", file.path(folder, "GLM", "outflow.csv"))
      }
    }

    ##### GOTM
    if("GOTM" %in% model){

      yaml <- file.path(folder, get_yaml_value(config_file, "config_files", "GOTM"))

      gotm_outfile <- "inflow_file.dat"

      gotm_outfpath <- file.path(folder, "GOTM", gotm_outfile)

      gotm_inflow <- format_inflow(inflow, model = "GOTM", config_file = config_file)

      #Scale met
      if(!is.null(scale_param_inf)){
        scale_met(gotm_inflow, pars = scale_param_inf, model = "GOTM", out_file = gotm_outfpath)
      }else{
        # Write to file
        write.table(gotm_inflow, gotm_outfpath, quote = FALSE, row.names = FALSE, sep = "\t",
                    col.names = TRUE)
      }

      message("GOTM: Created file ", file.path(folder, "GOTM", gotm_outfile))

      if(use_c_outflows){
        temp_fil <- get_yaml_value(config_file, "config_files", "GOTM")
        got_yaml <- file.path(folder, temp_fil)
        input_yaml_multiple(got_yaml, key1 = "streams", key2 = "outflow", key3 = "flow", key4 =
                              "method", value = 2)
        input_yaml_multiple(got_yaml, key1 = "streams", key2 = "outflow", key3 = "temp", key4 =
                              "method", value = 0)
        input_yaml_multiple(got_yaml, key1 = "streams", key2 = "outflow", key3 = "salt", key4 =
                              "method", value = 0)

        gotm_outflow <- gotm_inflow[, c(1:2)]
        gotm_outflow[,2] <- gotm_outflow[,2] * -1
        gotm_outflowfile <- "outflow_file.dat"
        gotm_outflowfpath <- file.path(folder, "GOTM", gotm_outflowfile)

        write.table(gotm_outflow, gotm_outflowfpath, quote = FALSE, row.names = FALSE, sep = "\t",
                    col.names = TRUE)

        message("GOTM: Created outflow file ", file.path(folder, "GOTM", gotm_outflowfile))
      }

    }

    ## Simstrat
    if("Simstrat" %in% model){

      inflow_outfile <- "Qin.dat"
      temp_outfile <- "Tin.dat"
      salt_outfile <- "Sin.dat"
      par_file <- file.path(folder, get_yaml_value(config_file, "config_files", "Simstrat"))

      inflow_outfpath <- file.path(folder, "Simstrat", inflow_outfile)
      temp_outfpath <- file.path(folder, "Simstrat", temp_outfile)
      salt_outfpath <- file.path(folder, "Simstrat", salt_outfile)

      sim_inflow <- format_inflow(inflow = inflow, model = "Simstrat", config_file = config_file)

      ## Set Qin and Qout to 0 inflow
      inflow_line_1 <- "Time [d]\tQ_in [m3/s]"
      inflow_line_2 <- "1"
      inflow_line_3 <- "-1 0.00"
      inflow_line_4 <- paste(seq_len(length(sim_inflow$datetime)), sim_inflow$Flow_metersCubedPerSecond)
      file_connection <- file(inflow_outfpath)
      writeLines(c(inflow_line_1, inflow_line_2, inflow_line_3, inflow_line_4),
                 file_connection)
      close(file_connection)

      inflow_line_1 <- "Time [d]\tT_in [degC]"
      inflow_line_4 <- paste(seq_len(length(sim_inflow$datetime)), sim_inflow$Water_Temperature_celsius)
      file_connection <- file(temp_outfpath)
      writeLines(c(inflow_line_1, inflow_line_2, inflow_line_3, inflow_line_4),
                 file_connection)
      close(file_connection)

      inflow_line_1 <- "Time [d]\tS_in [perMille]"
      inflow_line_4 <- paste(seq_len(length(sim_inflow$datetime)), sim_inflow$Salinity_practicalSalinityUnits)
      file_connection <- file(salt_outfpath)
      writeLines(c(inflow_line_1, inflow_line_2, inflow_line_3, inflow_line_4),
                 file_connection)
      close(file_connection)

     
      message("Simstrat: Created file ", file.path(folder, "Simstrat", inflow_outfile))

      if(use_c_outflows){
        outflow_outfile <- "Qout.dat"
        par_file <- file.path(folder, get_yaml_value(config_file, "config_files", "Simstrat"))

        outflow_outfpath <- file.path(folder, "Simstrat", outflow_outfile)

        sim_inflow$Flow_metersCubedPerSecond <- sim_inflow$Flow_metersCubedPerSecond * (- 1)

        inflow_line_1 <- "Time [d]\tQ_in [m3/s]"
        inflow_line_2 <- "1"
        inflow_line_3 <- "-1 0.00"
        inflow_line_4 <- paste(seq_len(length(sim_inflow$datetime)), sim_inflow$Flow_metersCubedPerSecond)
        file_connection <- file(outflow_outfpath)
        writeLines(c(inflow_line_1, inflow_line_2, inflow_line_3, inflow_line_4),
                   file_connection)
        close(file_connection)

        message("Simstrat: Created outflow file ", file.path(folder, "Simstrat", outflow_outfile))
      }
    }

    ## MyLake
    if("MyLake" %in% model){

      temp_fil <- get_yaml_value(config_file, "config_files", "MyLake")
      load(temp_fil)

      if(num_inflows > 1) {
        # mylake_inflow <- average inflows from list
      } else {
        mylake_inflow <- inflow
      }
      
      mylake_inflow <- format_inflow(inflow = mylake_inflow, model = "MyLake", config_file = config_file)

      # discharge [m3/d], temperature [deg C], conc of passive tracer [-], conc of passive
      # sediment tracer [-], TP [mg/m3], DOP [mg/m3], Chla [mg/m3], DOC [mg/m3]
      dummy_inflow <- matrix(rep(1e-10, 8 *
                                   length(seq.POSIXt(from = as.POSIXct(start_date),
                                                            to = as.POSIXct(stop_date),
                                                            by = "day"))),
                             ncol = 8)
      dummy_inflow[, 1] <- mylake_inflow$Flow_metersCubedPerDay
      dummy_inflow[, 2] <- mylake_inflow$Water_Temperature_celsius
      dummy_inflow[, 5] <- dummy_inflow[, 5] * 1e7
      dummy_inflow[, 6] <- dummy_inflow[, 6] * 1e1


      mylake_config[["Inflw"]] <- dummy_inflow

      temp_fil <- gsub(".*/", "", temp_fil)
      # save lake-specific config file for MyLake
      save(mylake_config, file = file.path(folder, "MyLake", temp_fil))

      message("MyLake: Created file ", file.path(folder, "MyLake", temp_fil))

      if(use_outflows){
        message("MyLake does not need specific outflows, as it employs automatic overflow.")
      }
    }
  }
  
  ##-------------If outflow == TRUE---------------
  
  if(use_outflows == TRUE){
    
    outflow_file <- get_yaml_value(file = config_file, label = "outflows", key = "file")
    # Check if file exists
    if(!file.exists(outflow_file)){
      stop(outflow_file, " does not exist. Check filepath in ", config_file)
    }
    
    ### Import data
    message("Loading outflow data...")
    outflow <- read.csv(file.path(folder, outflow_file), stringsAsFactors = FALSE)
    outflow[, 1] <- as.POSIXct(outflow[, 1])
    # Check time step
    tstep <- diff(as.numeric(outflow[, 1]))
    
    start_date <- get_yaml_value(config_file, "time", "start")
    # Stop date
    stop_date <- get_yaml_value(config_file, "time", "stop")
    
    outflow_start <- which(outflow$datetime == as.POSIXct(start_date))
    outflow_stop <- which(outflow$datetime == as.POSIXct(stop_date))
    
    outflow <- outflow[outflow_start:outflow_stop, ]
    
    ### Naming conventions standard input
    # remove numbers if multiple inflows are present
    cln_outf <- colnames(outflow)
    if(num_outflows > 1) {
      cln_outf <- gsub("(\\w+)\\_\\d+\\>", "\\1", cln_outf)
    }
    # test if names are right
    chck_outflow <- sapply(list(cln_outf), function(x) x %in% lake_var_dic$standard_name)
    if(any(!chck_outflow)){
      chck_outflow[which(chck_outflow == FALSE)] <- sapply(list(cln_outf[which(
        chck_outflow == FALSE)]), function(x) x %in% met_var_dic$standard_name)
      
      if(any(!chck_outflow)){
        stop("Colnames of outflow file are not in standard notation! ",
             "They should be one of: \ndatetime\nFlow_metersCubedPerSecond\n",
             "Water_Temperature_celsius\nSalinity_practicalSalinityUnits")
      }
    }
    ## appy scaling
    if(num_outflows == 1) {
      outflow[["Flow_metersCubedPerSecond"]] <- outflow[["Flow_metersCubedPerSecond"]] *
        scale_param_out
    } else if(num_outflows > 1) {
      for (i in 1:num_outflows) {
        outflow[[paste0("Flow_metersCubedPerSecond_", i)]] <-
          outflow[[paste0("Flow_metersCubedPerSecond_", i)]] * scale_param_out[i]
      }
    }
    
    # if multiple outflows are present put them in a list
    if(num_outflows > 1) {
      outflow_ls <- list()
      for (i in 1:num_outflows) {
        outflow_ls[[paste0("outflow_", i)]] <-
          data.frame(datetime = inflow$datetime,
                     Flow_metersCubedPerSecond = outflow[[paste0("Flow_metersCubedPerSecond_", i)]])
      }
      outflow <- outflow_ls
      rm(outflow_ls)
    }
    
    # FLake
    #####
    if("FLake" %in% model){
        message("FLake does not need outflows, as mass fluxes are not considered.")
    }
    
    # GLM
    #####
    if("GLM" %in% model){
      if(num_outflows == 1) {
        glm_outflow <- format_outflow(outflow = outflow, model = "GLM", config_file = config_file)
        
        outflow_outfile <- file.path("GLM", "outflow.csv")
        write.csv(glm_outflow, outflow_outfile, row.names = FALSE, quote = FALSE)
        message("GLM: Created file ", file.path(folder, "GLM", "outflow_file.csv"))
      } else if (num_outflows > 1) {
        for (i in 1:num_outflows) {
          glm_outflow <- format_outflow(outflow = outflow[[i]], model = "GLM",
                                      config_file = config_file)
          
          outflow_outfile <- file.path("GLM", paste0("outflow_", i, ".csv"))
          write.csv(glm_outflow, outflow_outfile, row.names = FALSE, quote = FALSE)
          message("GLM: Created file ", file.path(folder, "GLM", paste0("outflow_", i, ".csv")))
        }
      }
    }
    
    ## GOTM
    if("GOTM" %in% model){
      
      yaml <- file.path(folder, get_yaml_value(config_file, "config_files", "GOTM"))
      
      gotm_outfile <- "inflow_file.dat"
      
      gotm_outfpath <- file.path(folder, "GOTM", gotm_outfile)
      
      gotm_inflow <- format_inflow(inflow, model = "GOTM", config_file = config_file)
      
      #Scale met
      if(!is.null(scale_param_inf)){
        scale_met(gotm_inflow, pars = scale_param_inf, model = "GOTM", out_file = gotm_outfpath)
      }else{
        # Write to file
        write.table(gotm_inflow, gotm_outfpath, quote = FALSE, row.names = FALSE, sep = "\t",
                    col.names = TRUE)
      }
      
      message("GOTM: Created file ", file.path(folder, "GOTM", gotm_outfile))
      
      if(use_c_outflows){
        temp_fil <- get_yaml_value(config_file, "config_files", "GOTM")
        got_yaml <- file.path(folder, temp_fil)
        input_yaml_multiple(got_yaml, key1 = "streams", key2 = "outflow", key3 = "flow", key4 =
                              "method", value = 2)
        input_yaml_multiple(got_yaml, key1 = "streams", key2 = "outflow", key3 = "temp", key4 =
                              "method", value = 0)
        input_yaml_multiple(got_yaml, key1 = "streams", key2 = "outflow", key3 = "salt", key4 =
                              "method", value = 0)
        
        gotm_outflow <- gotm_inflow[, c(1:2)]
        gotm_outflow[,2] <- gotm_outflow[,2] * -1
        gotm_outflowfile <- "outflow_file.dat"
        gotm_outflowfpath <- file.path(folder, "GOTM", gotm_outflowfile)
        
        write.table(gotm_outflow, gotm_outflowfpath, quote = FALSE, row.names = FALSE, sep = "\t",
                    col.names = TRUE)
        
        message("GOTM: Created outflow file ", file.path(folder, "GOTM", gotm_outflowfile))
      }
      
    }
    
    ## Simstrat
    if("Simstrat" %in% model){
      
      inflow_outfile <- "Qin.dat"
      temp_outfile <- "Tin.dat"
      salt_outfile <- "Sin.dat"
      par_file <- file.path(folder, get_yaml_value(config_file, "config_files", "Simstrat"))
      
      inflow_outfpath <- file.path(folder, "Simstrat", inflow_outfile)
      temp_outfpath <- file.path(folder, "Simstrat", temp_outfile)
      salt_outfpath <- file.path(folder, "Simstrat", salt_outfile)
      
      sim_inflow <- format_inflow(inflow = inflow, model = "Simstrat", config_file = config_file)
      
      ## Set Qin and Qout to 0 inflow
      inflow_line_1 <- "Time [d]\tQ_in [m3/s]"
      inflow_line_2 <- "1"
      inflow_line_3 <- "-1 0.00"
      inflow_line_4 <- paste(seq_len(length(sim_inflow$datetime)), sim_inflow$Flow_metersCubedPerSecond)
      file_connection <- file(inflow_outfpath)
      writeLines(c(inflow_line_1, inflow_line_2, inflow_line_3, inflow_line_4),
                 file_connection)
      close(file_connection)
      
      inflow_line_1 <- "Time [d]\tT_in [degC]"
      inflow_line_4 <- paste(seq_len(length(sim_inflow$datetime)), sim_inflow$Water_Temperature_celsius)
      file_connection <- file(temp_outfpath)
      writeLines(c(inflow_line_1, inflow_line_2, inflow_line_3, inflow_line_4),
                 file_connection)
      close(file_connection)
      
      inflow_line_1 <- "Time [d]\tS_in [perMille]"
      inflow_line_4 <- paste(seq_len(length(sim_inflow$datetime)), sim_inflow$Salinity_practicalSalinityUnits)
      file_connection <- file(salt_outfpath)
      writeLines(c(inflow_line_1, inflow_line_2, inflow_line_3, inflow_line_4),
                 file_connection)
      close(file_connection)
      
      message("Simstrat: Created file ", file.path(folder, "Simstrat", inflow_outfile))
      
      if(use_c_outflows){
        outflow_outfile <- "Qout.dat"
        par_file <- file.path(folder, get_yaml_value(config_file, "config_files", "Simstrat"))
        
        outflow_outfpath <- file.path(folder, "Simstrat", outflow_outfile)
        
        sim_inflow$Flow_metersCubedPerSecond <- sim_inflow$Flow_metersCubedPerSecond * (- 1)
        
        inflow_line_1 <- "Time [d]\tQ_in [m3/s]"
        inflow_line_2 <- "1"
        inflow_line_3 <- "-1 0.00"
        inflow_line_4 <- paste(seq_len(length(sim_inflow$datetime)), sim_inflow$Flow_metersCubedPerSecond)
        file_connection <- file(outflow_outfpath)
        writeLines(c(inflow_line_1, inflow_line_2, inflow_line_3, inflow_line_4),
                   file_connection)
        close(file_connection)
        
        message("Simstrat: Created outflow file ", file.path(folder, "Simstrat", outflow_outfile))
      }
    }
    
    ## MyLake
    if("MyLake" %in% model){
      
        message("MyLake does not need specific outflows, as it employs automatic overflow.")
  }
  

  message("export_inflow complete!")
}

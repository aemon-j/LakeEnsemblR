#' Export LakeEnsemblR standardised flow files to model specific driver format
#'
#' Export in- anbd out-flow driver files for each model
#'
#' @param config_file filepath; to LakeEnsemblr yaml master config file
#' @param model vector; model to export driving data. Options include
#'    c("GOTM", "GLM", "Simstrat", "FLake", "MyLake")
#' @param folder filepath; to folder which contains the model folders generated by export_config()
#'
#' @examples
#' \dontrun{
#' export_inflow(config_file, model = c("GOTM", "GLM", "Simstrat", "FLake", "MyLake"))
#' }
#' @importFrom gotmtools get_yaml_value calc_cc input_yaml
#' @importFrom glmtools read_nml set_nml write_nml
#'
#' @export
export_inflow <- function(config_file, model = c("GOTM", "GLM", "Simstrat", "FLake", "MyLake"),
                          folder = ".") {

  # It's advisable to set timezone to GMT in order to avoid errors when reading time
  original_tz  <-  Sys.getenv("TZ")
  Sys.setenv(TZ = "UTC")

  # Set working directory
  oldwd <- getwd()
  setwd(folder)

  # this way if the function exits for any reason, success or failure, these are reset:
  on.exit({
    setwd(oldwd)
    Sys.setenv(TZ = original_tz)
  })

  # check model input
  model <- check_models(model)

##-------------Read settings---------------
  # initial water level
  init_lvl <- get_yaml_value(config_file, "location", "init_depth")
  # surface elevation
  surf_lvl <- get_yaml_value(config_file, "location", "elevation")
  # bottom elevation
  bot_lvl <- surf_lvl - get_yaml_value(config_file, "location", "depth")

  # Get start & stop dates
  start_date <- get_yaml_value(config_file, "time", "start")
  stop_date <- get_yaml_value(config_file, "time", "stop")

  # Use inflows
  use_inflows <- get_yaml_value(config_file, "inflows", "use")
  # Use outflows
  use_outflows <- get_yaml_value(config_file, "outflows", "use")

  tryCatch({get_yaml_value(config_file, "inflows", "mass-balance")
    warning(paste0("The 'mass-balance' argument is no longer used ",
                   "if you would like to have outflows matching the ",
                   "inflows please add them manually to the 'outflows'",
                   " section. You can use the same file as for inflows."))},
           error = function(e) { })
  if(use_outflows) {
    # number of outflows
    num_outflows <- get_yaml_value(config_file, "outflows", "number_outflows")
    # outflow depths
    lvl_outflows <- get_yaml_value(config_file, "outflows", "outflow_lvl")
    # Get scaling parameter
    scale_param_out <- get_yaml_value(config_file, "outflows", "scale_param")
  }

  if(use_inflows) {
    # Get scaling parameter
    scale_param_inf <- get_yaml_value(config_file, "inflows", "scale_param")
    # number of inflows
    num_inflows <- get_yaml_value(config_file, "inflows", "number_inflows")
  }


##---------------FLake-------------

  if("FLake" %in% model){
    fla_fil <- file.path(folder, get_yaml_value(config_file, "config_files", "FLake"))

    if(!use_inflows){
      input_nml(fla_fil, label = "inflow", key = "Qfromfile",  ".false.")
    }else{
      input_nml(fla_fil, label = "inflow", key = "Qfromfile",  ".true.")
    }
  }

##---------------GLM-------------

  if("GLM" %in% model){
    glm_nml <- file.path(folder, get_yaml_value(config_file, "config_files", "GLM"))

    # Read in nml and input parameters
    nml <- read_nml(glm_nml)
    # if no inflow or outflow is used  this list is keep otherwise it is changed
    inp_list <- list("num_inflows" = 0, "num_outlet" = 0)
    # set inflow
    if (use_inflows) {
      inp_list$num_inflows  <-  num_inflows
      inp_list <- c(inp_list, list("names_of_strms" = paste0("inflow_", 1:num_inflows),
                                   "strm_hf_angle" = rep(65, num_inflows),
                                   "strmbd_slope" = rep(2, num_inflows),
                                   "strmbd_drag" = rep(0.016, num_inflows),
                                   "inflow_factor" = rep(1, num_inflows),
                                   "inflow_fl" = paste0("inflow_", 1:num_inflows, ".csv")))
    }

    # set outflows
    if (use_outflows){
      outf_surf <- rep(FALSE, num_outflows)
      outf_surf[lvl_outflows == -1] <- TRUE
      #!! outflow elevations need to be in meters above sea level!!
      lvl_outflows_glm <- lvl_outflows + bot_lvl
      # outflow lvl for floating outflows is set to 0
      lvl_outflows_glm[lvl_outflows == -1] <- 0
      inp_list$num_outlet <- num_outflows
      inp_list <- c(inp_list, list("flt_off_sw" = outf_surf,
                                   "outl_elvs" = lvl_outflows_glm,
                                   "outflow_fl" = paste0("outflow_", 1:num_outflows, ".csv"),
                                   "outflow_factor" = rep(1, num_outflows)))
    }

    nml <- glmtools::set_nml(nml, arg_list = inp_list)
    write_nml(nml, glm_nml)

  }

##---------------GOTM-------------

  if("GOTM" %in% model) {
    got_yaml <- file.path(folder, get_yaml_value(config_file, "config_files", "GOTM"))
    yml_no_comment <- unname(sapply(readLines(got_yaml), function(x) strsplit(x, "#")[[1]][1]))
    # number of inflows in the yaml file so far
    num_inf_yaml <- length(grep("inflow\\_*\\d*:", yml_no_comment, value = TRUE))

    # number of outflows in the yaml file so far
    num_outf_yaml <- length(grep("outflow\\_*\\d*:", yml_no_comment, value = TRUE))


    ## Switch off streams
    if(!use_inflows) {
      # switch of flexible water level
      input_yaml_multiple(got_yaml, key1 = "mimic_3d", key2 = "zeta", key3 = "method",
                          value = 0)
      input_yaml_multiple(got_yaml, key1 = "water_balance_method", value = 0)
      # remove all inflows but one
      if (num_inf_yaml > 1) {
        for (i in 2:(num_inf_yaml)) {
          rm_yaml_sec(got_yaml, paste0("inflow_", i))
          num_inf_yaml <- 1
        }
      }
      # streams_switch(file = got_yaml, method = "off")
      input_yaml_multiple(got_yaml, key1 = "streams", key2 = "inflow", key3 = "flow", key4 =
                            "method", value = 0)
      input_yaml_multiple(got_yaml, key1 = "streams", key2 = "inflow", key3 = "temp", key4 =
                            "method", value = 0)
      input_yaml_multiple(got_yaml, key1 = "streams", key2 = "inflow", key3 = "salt", key4 =
                            "method", value = 0)
    }
    if (!use_outflows) {
      # remove all outflows but one
      if (num_outf_yaml > 1) {
        for (i in 2:(num_outf_yaml)) {
          rm_yaml_sec(got_yaml, paste0("outflow_", i))
          num_outf_yaml <- 1
        }
      }
      input_yaml_multiple(got_yaml, key1 = "streams", key2 = "outflow", key3 = "flow", key4 =
                            "method", value = 0)
      input_yaml_multiple(got_yaml, key1 = "streams", key2 = "outflow", key3 = "temp", key4 =
                            "method", value = 0)
      input_yaml_multiple(got_yaml, key1 = "streams", key2 = "outflow", key3 = "salt", key4 =
                            "method", value = 0)
    }
    # set inflows
    if (use_inflows) {
      # switch on flexible water level
      input_yaml_multiple(got_yaml, key1 = "mimic_3d", key2 = "zeta", key3 = "method",
                          value = 3)
      input_yaml_multiple(got_yaml, key1 = "water_balance_method", value = 3)
      # remove additional inflows that are not needed
      if (num_inf_yaml > num_inflows) {
        for (i in 2:(num_inf_yaml)) {
          rm_yaml_sec(got_yaml, paste0("inflow_", i))
          num_inf_yaml <- 1
        }
      }
      # add additional inflows if necessary
      if(num_inflows > 1 & num_inflows != num_inf_yaml) {
        for (i in num_inflows:2) {
          doubl_yaml_sec(got_yaml, "inflow", paste0("_", i))
          num_inf_yaml <- num_inflows
        }
      }
        # set inflow settings for all inflows
        for (i in 1:num_inflows) {

          if(i == 1) {
            inf_sec <- "inflow"
          } else {
            inf_sec <- paste0("inflow_", i)
          }

          # streams_switch(file = got_yaml, method = "on")
          input_yaml_multiple(got_yaml, key1 = "streams", key2 = inf_sec, key3 = "flow", key4 =
                                "method", value = 2)
          input_yaml_multiple(got_yaml, key1 = "streams", key2 = inf_sec, key3 = "temp", key4 =
                                "method", value = 2)
          input_yaml_multiple(got_yaml, key1 = "streams", key2 = inf_sec, key3 = "salt", key4 =
                                "method", value = 2)
          input_yaml_multiple(got_yaml, key1 = "streams", key2 = inf_sec, key3 = "flow", key4 =
                                "file", value = paste0("inflow_file_", i, ".dat"))
          input_yaml_multiple(got_yaml, key1 = "streams", key2 = inf_sec, key3 = "temp", key4 =
                                "file", value = paste0("inflow_file_", i, ".dat"))
          input_yaml_multiple(got_yaml, key1 = "streams", key2 = inf_sec, key3 = "salt", key4 =
                                "file", value = paste0("inflow_file_", i, ".dat"))
        }
      }

    # set outflows
    if (use_outflows) {
      if (!use_inflows) {
        # switch on flexible water level
        input_yaml_multiple(got_yaml, key1 = "mimic_3d", key2 = "zeta", key3 = "method",
                            value = 3)
        input_yaml_multiple(got_yaml, key1 = "water_balance_method", value = 3)
      }
      # remove additional outflows that are not needed
      if (num_outf_yaml > num_outflows) {
        for (i in 2:(num_outf_yaml)) {
          rm_yaml_sec(got_yaml, paste0("outflow_", i))
          num_outf_yaml <- 1
        }
      }
      outf_surf <- rep(FALSE, num_outflows)
      outf_surf[lvl_outflows == -1] <- TRUE
      # outflow lvl in GOTM are meters below initial surface lvl
      lvl_outflows_gotm <- lvl_outflows - init_lvl
      # add additional outflows if necessary
      if(num_outflows > 1 & num_outflows != num_outf_yaml) {
        for (i in num_outflows:2) {
          doubl_yaml_sec(got_yaml, "outflow", paste0("_", i))
          num_outf_yaml <- num_outflows
        }
      }
        # set outflow settings for all outflows
        for (i in 1:num_outflows) {
          if(i == 1) {
            outf_sec <- "outflow"
          } else {
            outf_sec <- paste0("outflow_", i)
          }
          # streams_switch(file = got_yaml, method = "on")
          input_yaml_multiple(got_yaml, key1 = "streams", key2 = outf_sec, key3 = "method",
                              value = ifelse(outf_surf[i], 1, 3))
          input_yaml_multiple(got_yaml, key1 = "streams", key2 = outf_sec, key3 = "zl",
                              value = lvl_outflows_gotm[i] - 0.5)
          input_yaml_multiple(got_yaml, key1 = "streams", key2 = outf_sec, key3 = "zu",
                              value = lvl_outflows_gotm[i] + 0.5)
          input_yaml_multiple(got_yaml, key1 = "streams", key2 = outf_sec, key3 = "flow", key4 =
                                "method", value = 2)
          input_yaml_multiple(got_yaml, key1 = "streams", key2 = outf_sec, key3 = "temp", key4 =
                                "method", value = 0)
          input_yaml_multiple(got_yaml, key1 = "streams", key2 = outf_sec, key3 = "salt", key4 =
                                "method", value = 0)
          input_yaml_multiple(got_yaml, key1 = "streams", key2 = outf_sec, key3 = "flow", key4 =
                                "file", value = paste0("outflow_file_", i, ".dat"))
          input_yaml_multiple(got_yaml, key1 = "streams", key2 = outf_sec, key3 = "temp", key4 =
                                "file", value = paste0("outflow_file_", i, ".dat"))
          input_yaml_multiple(got_yaml, key1 = "streams", key2 = outf_sec, key3 = "salt", key4 =
                                "file", value = paste0("outflow_file_", i, ".dat"))
      }
    }
   }

##---------------Simstrat-------------

  if("Simstrat" %in% model){
    sim_par <- file.path(folder, get_yaml_value(config_file, "config_files", "Simstrat"))
    # Turn off inflow
    if(!use_inflows){
      ## Set Qin and Qout to 0 inflow
      inflow_line_1 <- "Time [d]\tQ_in [m3/s]"
      # In case Kw is a single value for the whole simulation:
      inflow_line_2 <- "1"
      inflow_line_3 <- "-1 0.00"
      start_sim <- get_json_value(sim_par, "Simulation", "Start d")
      end_sim <- get_json_value(sim_par, "Simulation", "End d")
      inflow_line_4 <- paste(start_sim, 0.000)
      inflow_line_5 <- paste(end_sim, 0.000)

      file_connection <- file("Simstrat/Qin.dat")
      writeLines(c(inflow_line_1, inflow_line_2, inflow_line_3, inflow_line_4, inflow_line_5),
                 file_connection)
      close(file_connection)
      file_connection <- file("Simstrat/Qout.dat")
      writeLines(c(inflow_line_1, inflow_line_2, inflow_line_3, inflow_line_4, inflow_line_5),
                 file_connection)
      close(file_connection)
    }
    if(!use_outflows){
      outflow_outfile <- "Qout.dat"

      outflow_outfpath <- file.path(folder, "Simstrat", outflow_outfile)

      outflow_line_1 <- "Time [d]\tQ_out [m3/s]"
      outflow_line_2 <- "1"
      outflow_line_3 <- "-1 0.00"
      start_sim <- get_json_value(sim_par, "Simulation", "Start d")
      end_sim <- get_json_value(sim_par, "Simulation", "End d")
      outflow_line_4 <- paste(start_sim, 0.000)
      outflow_line_5 <- paste(end_sim, 0.000)
      file_connection <- file(outflow_outfpath)
      writeLines(c(outflow_line_1, outflow_line_2, outflow_line_3, outflow_line_4,
                   outflow_line_5), file_connection)
      close(file_connection)
    }
  }

##---------------MyLake-------------

  if("MyLake" %in% model){
    # Load config file MyLake
    load(get_yaml_value(config_file, "config_files", "MyLake"))

    if(!use_inflows){
      mylake_config[["Inflw"]] <- matrix(rep(0, 8 * length(seq.POSIXt(from = as.POSIXct(start_date),
                                                                    to = as.POSIXct(stop_date),
                                                                    by = "day"))),
                                         ncol = 8)

      # save lake-specific config file for MyLake
      temp_fil <- gsub(".*/", "", get_yaml_value(config_file, "config_files", "MyLake"))
      save(mylake_config, file = file.path(folder, "MyLake", temp_fil))
    }
  }

##-------------If inflow == TRUE---------------

  if(use_inflows == TRUE){
    inflow_file <- get_yaml_value(file = config_file, label = "inflows", key = "file")
    # Check if file exists
    if(!file.exists(inflow_file)){
      stop(inflow_file, " does not exist. Check filepath in ", config_file)
    }
    ### Import data
    message("Loading inflow data...")
    inflow <- read.csv(file.path(folder, inflow_file), stringsAsFactors = FALSE)
    inflow[, 1] <- as.POSIXct(inflow[, 1])
    start_date <- get_yaml_value(config_file, "time", "start")
    # Stop date
    stop_date <- get_yaml_value(config_file, "time", "stop")
    inflow_start <- which(inflow$datetime == as.POSIXct(start_date))
    inflow_stop <- which(inflow$datetime == as.POSIXct(stop_date))
    inflow <- inflow[inflow_start:inflow_stop, ]

    ### Naming conventions standard input
    chk_names_flow(inflow, num_inflows, inflow_file)

    ### Apply scaling
    inflow <- scale_flow(inflow, num_inflows, scale_param_inf)

    # if multiple inflows are present put them in a list
    if(num_inflows > 1) {
      inflow_ls <- list()
      for (i in 1:num_inflows) {
        inflow_ls[[paste0("inflow_", i)]] <-
          data.frame(datetime = inflow$datetime,
                     Flow_metersCubedPerSecond = inflow[[paste0("Flow_metersCubedPerSecond_", i)]],
                     Water_Temperature_celsius = inflow[[paste0("Water_Temperature_celsius_", i)]],
                     Salinity_practicalSalinityUnits =
                       inflow[[paste0("Salinity_practicalSalinityUnits_", i)]]
                     )
      }
      inflow <- inflow_ls
      rm(inflow_ls)
    } else {
      inflow <- list(inflow_1 = inflow)
    }

    ##### FLake
    if("FLake" %in% model){


      flake_inflow <- format_inflow(inflow = inflow, model = "FLake", config_file = config_file)

      flake_outfile <- "Tinflow"

      flake_outfpath <- file.path(folder, "FLake", flake_outfile)

      write.table(flake_inflow, flake_outfpath, quote = FALSE, row.names = FALSE, sep = "\t",
                  col.names = FALSE)


      temp_fil <- get_yaml_value(config_file, "config_files", "FLake")
      input_nml(temp_fil, label = "inflow", key = "time_step_number", nrow(flake_inflow))

      message("FLake: Created file ", file.path(folder, "FLake", flake_outfile))

      if(use_outflows){
        message("FLake does not need outflows, as mass fluxes are not considered.")
      }

    }

    ###### GLM
    if("GLM" %in% model){
      for (i in 1:num_inflows) {
        glm_inflow <- format_inflow(inflow = inflow[[i]], model = "GLM",
                                    config_file = config_file)

        inflow_outfile <- file.path("GLM", paste0("inflow_", i, ".csv"))
        write.csv(glm_inflow, inflow_outfile, row.names = FALSE, quote = FALSE)
        message("GLM: Created file ", file.path(folder, "GLM", paste0("inflow_", i, ".csv")))
      }
    }

    ##### GOTM
    if("GOTM" %in% model){

      for (i in 1:num_inflows) {
        gotm_outfile <- paste0("inflow_file_", i, ".dat")
        gotm_outfpath <- file.path(folder, "GOTM", gotm_outfile)
        gotm_inflow <- format_inflow(inflow[[i]], model = "GOTM", config_file = config_file)

        write.table(gotm_inflow, gotm_outfpath, quote = FALSE, row.names = FALSE, sep = "\t",
                    col.names = TRUE)

        message("GOTM: Created file ", file.path(folder, "GOTM", gotm_outfile))
      }

    }

    ## Simstrat
    if("Simstrat" %in% model){
      # output file names
      inflow_outfile <- "Qin.dat"
      temp_outfile <- "Tin.dat"
      salt_outfile <- "Sin.dat"
      # output file paths
      inflow_outfpath <- file.path(folder, "Simstrat", inflow_outfile)
      temp_outfpath <- file.path(folder, "Simstrat", temp_outfile)
      salt_outfpath <- file.path(folder, "Simstrat", salt_outfile)

      sim_inflow <- format_inflow(inflow = inflow, model = "Simstrat", config_file = config_file)

      ## inflow file
      inflow_line_1 <- "Time [d]\tQ_in [m3/s]"
      inflow_line_2 <- as.character(num_inflows)
      inflow_line_3 <- paste0("-1",  rep(" 0.00", num_inflows))
      if(num_inflows > 1) {
        inflow_line_4 <- seq_len(length(sim_inflow$datetime))
        for (i in 1:num_inflows) {
          inflow_line_4 <- paste(inflow_line_4,
                                 sim_inflow[, paste0("Flow_metersCubedPerSecond_", i)])
        }
      } else {
        inflow_line_4 <- paste(seq_len(length(sim_inflow$datetime)),
                               sim_inflow$Flow_metersCubedPerSecond)
      }
      file_connection <- file(inflow_outfpath)
      writeLines(c(inflow_line_1, inflow_line_2, inflow_line_3, inflow_line_4), file_connection)
      close(file_connection)
      # temperature file
      inflow_line_1 <- "Time [d]\tT_in [degC]"
      if(num_inflows > 1) {
        inflow_line_4 <- seq_len(length(sim_inflow$datetime))
        for (i in 1:num_inflows) {
          inflow_line_4 <- paste(inflow_line_4,
                                 sim_inflow[, paste0("Water_Temperature_celsius_", i)])
        }
      } else {
        inflow_line_4 <- paste(seq_len(length(sim_inflow$datetime)),
                               sim_inflow$Water_Temperature_celsius)
      }
      file_connection <- file(temp_outfpath)
      writeLines(c(inflow_line_1, inflow_line_2, inflow_line_3, inflow_line_4), file_connection)
      close(file_connection)
      # salinity file
      inflow_line_1 <- "Time [d]\tS_in [perMille]"
      if(num_inflows > 1) {
        inflow_line_4 <- seq_len(length(sim_inflow$datetime))
        for (i in 1:num_inflows) {
          inflow_line_4 <- paste(inflow_line_4,
                                 sim_inflow[, paste0("Salinity_practicalSalinityUnits_", i)])
        }
      } else {
        inflow_line_4 <- paste(seq_len(length(sim_inflow$datetime)),
                               sim_inflow$Salinity_practicalSalinityUnits)
      }
      file_connection <- file(salt_outfpath)
      writeLines(c(inflow_line_1, inflow_line_2, inflow_line_3, inflow_line_4),
                 file_connection)
      close(file_connection)

      message("Simstrat: Created file ", file.path(folder, "Simstrat", inflow_outfile))
    }

    ## MyLake
    if("MyLake" %in% model){

      temp_fil <- get_yaml_value(config_file, "config_files", "MyLake")
      load(temp_fil)

      mylake_inflow <- format_inflow(inflow = inflow, model = "MyLake",
                                     config_file = config_file)

      # discharge [m3/d], temperature [deg C], conc of passive tracer [-], conc of passive
      # sediment tracer [-], TP [mg/m3], DOP [mg/m3], Chla [mg/m3], DOC [mg/m3]
      dummy_inflow <- matrix(rep(1e-10, 8 *
                                   length(seq.POSIXt(from = as.POSIXct(start_date),
                                                            to = as.POSIXct(stop_date),
                                                            by = "day"))),
                             ncol = 8)
      dummy_inflow[, 1] <- mylake_inflow$Flow_metersCubedPerDay
      dummy_inflow[, 2] <- mylake_inflow$Water_Temperature_celsius
      dummy_inflow[, 5] <- dummy_inflow[, 5] * 1e7
      dummy_inflow[, 6] <- dummy_inflow[, 6] * 1e1


      mylake_config[["Inflw"]] <- dummy_inflow

      temp_fil <- gsub(".*/", "", temp_fil)
      # save lake-specific config file for MyLake
      save(mylake_config, file = file.path(folder, "MyLake", temp_fil))

      message("MyLake: Created file ", file.path(folder, "MyLake", temp_fil))

    }
  }

  ##-------------If outflow == TRUE---------------

  if(use_outflows == TRUE) {

    outflow_file <- get_yaml_value(file = config_file, label = "outflows", key = "file")
    # Check if file exists
    if(!file.exists(outflow_file)){
      stop(outflow_file, " does not exist. Check filepath in ", config_file)
    }

    ### Import data
    message("Loading outflow data...")
    outflow <- read.csv(file.path(folder, outflow_file), stringsAsFactors = FALSE)
    outflow[, 1] <- as.POSIXct(outflow[, 1])

    start_date <- get_yaml_value(config_file, "time", "start")
    # Stop date
    stop_date <- get_yaml_value(config_file, "time", "stop")

    outflow_start <- which(outflow$datetime == as.POSIXct(start_date))
    outflow_stop <- which(outflow$datetime == as.POSIXct(stop_date))

    outflow <- outflow[outflow_start:outflow_stop, ]

    ### Naming conventions standard input
    chk_names_flow(outflow, num_outflows, outflow_file)

    ### Apply scaling
    outflow <- scale_flow(outflow, num_outflows, scale_param_out)

    # if multiple outflows are present put them in a list
    if(num_outflows > 1) {
      outflow_ls <- list()
      for (i in 1:num_outflows) {
        outflow_ls[[paste0("outflow_", i)]] <-
          data.frame(datetime = outflow$datetime,
                     Flow_metersCubedPerSecond = outflow[[paste0("Flow_metersCubedPerSecond_", i)]])
      }
      outflow <- outflow_ls
      rm(outflow_ls)
    } else {
      outflow <- list(outflow_1 = outflow)
    }

    # FLake
    #####
    if("FLake" %in% model) {
        message("FLake does not need outflows, as mass fluxes are not considered.")
    }

    # GLM
    #####
    if("GLM" %in% model) {
      for (i in 1:num_outflows) {
        glm_outflow <- format_outflow(outflow = outflow[[i]], model = "GLM",
                                    config_file = config_file)

        outflow_outfile <- file.path("GLM", paste0("outflow_", i, ".csv"))
        write.csv(glm_outflow, outflow_outfile, row.names = FALSE, quote = FALSE)
        message("GLM: Created file ", file.path(folder, "GLM", paste0("outflow_", i, ".csv")))
      }
    }

    ## GOTM
    if("GOTM" %in% model) {

      for (i in 1:num_outflows) {

        gotm_outfile <- paste0("outflow_file_", i, ".dat")

        gotm_outfpath <- file.path(folder, "GOTM", gotm_outfile)

        gotm_outflow <- format_outflow(outflow[[i]], model = "GOTM", config_file = config_file)
        write.table(gotm_outflow, gotm_outfpath, quote = FALSE, row.names = FALSE, sep = "\t",
                    col.names = TRUE)

        message("GOTM: Created file ", file.path(folder, "GOTM", gotm_outfile))
      }
    }

    ## Simstrat
    if("Simstrat" %in% model) {

      outf_surf <- rep(FALSE, num_outflows)
      outf_surf[lvl_outflows == -1] <- TRUE
      #!! outflow elevations need to be relative to initial water level!!
      lvl_outflows_simstrat <- lvl_outflows - init_lvl
      lvl_outflows_simstrat[outf_surf] <- 0

      outflow_outfile <- "Qout.dat"

      outflow_outfpath <- file.path(folder, "Simstrat", outflow_outfile)
      sim_outflow <- format_outflow(outflow, "Simstrat", config_file, folder)
      ## inflow file
      outflow_line_1 <- "Time [d]\tQ_out [m3/s]"
      outflow_line_2 <- paste0(as.character(sum(!outf_surf)), " ", as.character(sum(outf_surf)))
      outflow_line_3 <- paste("-1",  lvl_outflows_simstrat[!outf_surf],
                              lvl_outflows_simstrat[outf_surf])
      if(num_outflows > 1) {
        outflow_line_4 <- seq_len(length(sim_outflow$datetime))
        # first the deep outflows
        for (i in ((1:num_outflows)[!outf_surf])) {
          outflow_line_4 <- paste(outflow_line_4,
                                 sim_outflow[, paste0("Flow_metersCubedPerSecond_", i)])
        }
        # then the surface oputflows
        for (i in ((1:num_outflows)[outf_surf])) {
          outflow_line_4 <- paste(outflow_line_4,
                                  sim_outflow[, paste0("Flow_metersCubedPerSecond_", i)])
        }
      } else {
        outflow_line_4 <- paste(seq_len(length(sim_outflow$datetime)),
                                sim_outflow$Flow_metersCubedPerSecond)
      }
      file_connection <- file(outflow_outfpath)
      writeLines(c(outflow_line_1, outflow_line_2, outflow_line_3, outflow_line_4), file_connection)
      close(file_connection)

      message("Simstrat: Created outflow file ", file.path(folder, "Simstrat", outflow_outfile))
    }

    ## MyLake
    if("MyLake" %in% model) {

        message("MyLake does not need specific outflows, as it employs automatic overflow.")
  }


  message("export_inflow complete!")
  }
}

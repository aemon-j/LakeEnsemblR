#' Create netcdf output from model-specific model runs
#'
#' Create a netcdf from lists of output, generated by run_ensemble
#'
#' @param output_lists list; list containing lists of output (e.g. temperature, ice_height)
#' @param folder filepath; to folder which contains the model folders generated by export_config()
#' @param out_time data frame; data frame with column ("datetime"),
#' describing at what times output should be generated
#' @import ncdf4
#' @importFrom rLakeAnalyzer get.offsets
#'
#' @export

create_netcdf_output <- function(output_lists, folder = ".", out_time,
                                 longitude = 0, latitude = 0, compression = 4,
                                 out_file = "ensemble_output.nc"){
  
  # Creat output directory
  message("Creating directory for output: ", file.path(folder, "output"))
  dir.create(file.path(folder, "output"), showWarnings = FALSE)
  
  #Create ncdf
  message("Creating NetCDF file [", Sys.time(), "]")
  ref_time <- as.POSIXct("1970-01-01 00:00:00", tz = "GMT") # Reference time for netCDF time
  # Calculate seconds since reference time
  nsecs <- as.numeric(difftime(out_time$datetime, ref_time, units = "secs"))
  xvals <- 180 - longitude # Convert longitude to degrees east
  yvals <- latitude # Latitude
  # Define lon and lat dimensions
  lon1 <- ncdf4::ncdim_def("lon", "degrees_east", vals = as.double(xvals))
  lat2 <- ncdf4::ncdim_def("lat", "degrees_north", vals = as.double(yvals))
  
  # Set dimensions
  # Time dimension
  timedim <- ncdf4::ncdim_def("time", units = "seconds since 1970-01-01 00:00:00",
                       vals = as.double(nsecs), calendar = "proleptic_gregorian")
  
  fillvalue <- 1e20 # Fill value
  missvalue <- 1e20 # Missing value
  
  nc_vars <- list() #Initialize empty list to fill netcdf variables
  
  for(i in seq_len(length(output_lists))){
    # Get variable name (e.g. "temp" from "temp_list")
    splitted_name <- strsplit(names(output_lists[[i]])[1], "_")[[1]]
    variable_name <- paste(splitted_name[2:length(splitted_name)], collapse = "_")
    
    # Get variable unit (from dictionary)
    variable_unit <- lake_var_dic$unit[lake_var_dic$short_name == variable_name]
    
    # See if it's 2D (e.g. ice height) or 3D (e.g. temperature)
    if(ncol(output_lists[[i]][[1]]) == 2){
      # Add 2D variable
      
      for(j in seq_len(length(output_lists[[i]]))) {
        model_name <- strsplit(names(output_lists[[i]])[j], "_")[[1]][1]
        # Long name
        lname <- paste(model_name, variable_name)
        # Define variable
        tmp_def <- ncdf4::ncvar_def(tolower(names(output_lists[[i]])[j]),
                                    variable_unit, list(lon1, lat2, timedim),
                                    fillvalue, lname, prec = "float", compression = compression,
                                    shuffle = FALSE)
        nc_vars[[length(nc_vars) + 1]] <- tmp_def # Add to list
      }
    }else if(ncol(output_lists[[i]][[1]]) > 2){
      # Add 3D variable
      
      lengths <- lapply(output_lists[[i]], ncol) # Extract ncols in each output
      lon_list <- which.max(lengths) # Select largest depths
      deps <- rLakeAnalyzer::get.offsets(output_lists[[i]][[lon_list]]) # Extract depths
      
      # Depth dimension
      depthdim <- ncdf4::ncdim_def("z", units = "meters", vals = as.double(rev(deps)),
                            longname = "Depth from surface")
      
      # For-loop over each model (and observations) in output_lists[[i]]
      for(j in seq_len(length(output_lists[[i]]))) {
        
        model_name <- strsplit(names(output_lists[[i]])[j], "_")[[1]][1]
        
        lname <- paste(model_name, variable_name)
        # Define variable
        tmp_def <- ncdf4::ncvar_def(tolower(names(output_lists[[i]])[j]), variable_unit,
                             list(lon1, lat2, timedim, depthdim), fillvalue, lname,
                             prec = "float", compression = compression, shuffle = FALSE)
        nc_vars[[length(nc_vars) + 1]] <- tmp_def # Add to list
      }
    }
    
    # Re-assign list names
    names(nc_vars)[(length(nc_vars) - length(output_lists[[i]]) + 1):length(nc_vars)] <-
      names(output_lists[[i]])
  }
  
  # Create file name for output file
  fname <- file.path(folder, "output", out_file) # Ensemble output filename
  
  # If file exists - delete it
  if(file.exists(fname)){
    unlink(fname, recursive = TRUE)
  }
  
  # Create and input data into the netCDF file
  ncout <- ncdf4::nc_create(fname, nc_vars, force_v4 = T)
  # Add coordinates attribute for use with get_vari()
  ncdf4::ncatt_put(ncout, "z", attname = "coordinates", attval = c("z"))
  
  # Loop through and add each variable
  # Add tryCatch ensure that it closes netCDF file
  result <- tryCatch({
    # Again different for 2D or 3D variables
    for(i in seq_len(length(output_lists))){
      
      if(ncol(output_lists[[i]][[1]]) == 2){
        # Add 2D variable
        for(j in seq_len(length(ice_list))) {
          
          mat <- as.matrix(ice_list[[j]][, -1])
          
          #Create index for nc_vars
          nc_idx <- length(nc_vars) - length(ice_list) + j
          
          ncdf4::ncvar_put(ncout, nc_vars[[nc_idx]], mat)
          ncdf4::ncatt_put(ncout, nc_vars[[nc_idx]], attname = "coordinates", attval = c("lon lat"))
          ncdf4::ncvar_change_missval(ncout, nc_vars[[j]], missval = fillvalue)
        }
        
      }else if(ncol(output_lists[[i]][[1]]) > 2){
        # Add 3D variable
        for(j in seq_len(length(temp_list))) {
          mat1 <- matrix(NA, nrow = nc_vars[[j]]$dim[[3]]$len, ncol = nc_vars[[j]]$dim[[4]]$len)
          
          # vector of depths to input into the matrix
          deps_temp <- rLakeAnalyzer::get.offsets(temp_list[[j]])
          
          mat <- as.matrix(temp_list[[j]][, -1])
          
          for(k in seq_len(ncol(mat))) {
            col <- which(deps == deps_temp[k])
            mat1[, col] <- mat[, k]
          }
          
          ncdf4::ncvar_put(ncout, nc_vars[[j]], mat1)
          ncdf4::ncatt_put(ncout, nc_vars[[j]], attname = "coordinates", attval = c("lon lat z"))
          ncdf4::ncvar_change_missval(ncout, nc_vars[[j]], missval = fillvalue)
        }
      }
    }
  }, warning = function(w) {
    return_val <- "Warning"
  }, error = function(e) {
    return_val <- "Error"
    warning("Error creating netCDF file!")
  }, finally = {
    nc_close(ncout) # Close netCDF file
  })
  
  message("Finished writing NetCDF file [", Sys.time(), "]")
  
}

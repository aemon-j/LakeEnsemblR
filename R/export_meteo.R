#' Export LakeEnsemblR standardized input to model specific driver format
#'
#'Export driver files for each model
#'
#' @param config_file filepath; to LakeEnsemblr yaml master config file
#' @param model vector; model to export driving data. Options include
#'    c('GOTM', 'GLM', 'Simstrat', 'FLake')
#' @param meteo_file filepath; to met file which is in the standardised LakeEnsemblR format. Uses
#' @param scale_param dataframe; with column names referring to standard names in LER.
#'    Scales meteorological value according to value in the column. Defaults to NULL.
#' @param folder filepath; to folder which contains the model folders generated by export_config()
#'
#' @examples
#' \dontrun{
#' export_meteo(model = c('GOTM', 'GLM', 'Simstrat', 'FLake'),
#'              meteo_file = 'LakeEnsemblR_meteo_standard.csv')
#' }
#' @importFrom gotmtools get_yaml_value calc_cc input_yaml
#' @importFrom glmtools read_nml set_nml write_nml
#' @importFrom zoo na.approx
#'
#' @export
export_meteo <- function(config_file, model = c("GOTM", "GLM", "Simstrat", "FLake", "MyLake"),
                         meteo_file = NULL, scale_param = NULL, folder = "."){

  # It's advisable to set timezone to GMT in order to avoid errors when reading time
  original_tz  <-  Sys.getenv("TZ")
  Sys.setenv(TZ = "GMT")

  # Set working directory
  oldwd <- getwd()

  # this way if the function exits for any reason, success or failure, these are reset:
  on.exit({
    setwd(oldwd)
    Sys.setenv(TZ = original_tz)
  })



  yaml  <-  file.path(folder, config_file)

  meteo_file <- get_yaml_value(file = yaml, label = "meteo", key = "file")
  # Check if file exists
  if(!file.exists(meteo_file)){
    stop(meteo_file, " does not exist. Check filepath in ", config_file)
  }

  ### Import data
  # I'd prefer to use a function that can read both comma and tab delimited.
  # data.table::fread does this, but then it's data.table
  message("Loading met data...")
  if(is.null(meteo_file)){
    meteo_file <- get_yaml_value(file = yaml, label = "meteo", key = "meteo_file")
  }
  met <- read.csv(file.path(folder, meteo_file), stringsAsFactors = F)
  met[, 1] <- as.POSIXct(met[, 1])
  # Check time step
  tstep <- diff(as.numeric(met[, 1]))

  if((mean(tstep) - 86400) / 86400 < -0.05) {
    daily <- FALSE
    subdaily <- TRUE
  } else {
    daily <- TRUE
    subdaily <- FALSE
  }

  ### Naming conventions standard input
  # test if names are right
  chck_met <- sapply(list(colnames(met)), function(x) x %in% met_var_dic$standard_name)
  if(any(!chck_met)) {
    stop(paste0("Colnames of meteo file are not in standard notation! ",
                "They should be one of: \n", paste0(met_var_dic$standard_name,
                                                  collapse = "\n")))
  }


  # FLake
  #####
  if("FLake" %in% model) {

    fla_met <- format_met(met = met, model = "FLake", daily = daily, config_file = config_file)

    # Met output file name
    met_outfile <- "all_meteo_file.dat"
    met_outfile <- file.path(folder, "FLake", met_outfile)


    #Scale met
    if(!is.null(scale_param)){
      scale_met(fla_met, pars = scale_param, model = "FLake", out_file = met_outfile)
    } else {
      # Write to file
      write.table(fla_met, met_outfile, sep = "\t", quote = FALSE, col.names = FALSE,
                  row.names = FALSE)
    }


    # Input values to nml
    nml_file <- file.path(folder, get_yaml_value(config_file, "config_files", "FLake"))

    input_nml(nml_file, "SIMULATION_PARAMS", "time_step_number", nrow(fla_met))
    input_nml(nml_file, "METEO", "meteofile", paste0("'", met_outfile, "'"))

    message("FLake: Created file ", file.path(folder, "FLake", met_outfile))


  }

  # GLM
  #####
  if("GLM" %in% model){
    glm_met <- format_met(met = met, model = "GLM", config_file = config_file, daily = daily)

    met_outfile <- file.path("GLM", "meteo_file.csv")

    #Scale met
    if(!is.null(scale_param)){
      scale_met(glm_met, pars = scale_param, model = "GLM", out_file = met_outfile)
    } else {
      # Write to file
      write.csv(glm_met, met_outfile, row.names = FALSE, quote = FALSE)
    }



    if("LongWave" %in% colnames(glm_met)){
      lw_type <- "LW_IN"
    } else {
      lw_type <- "LW_IN" ### Needs to be developed catch if no LW
    }


    # Input to nml file
    nml_path <- file.path(folder, get_yaml_value(config_file, "config_files", "GLM"))
    nml <- glmtools::read_nml(nml_path)

    nml_list <- list("subdaily" = subdaily, "lw_type" = lw_type, "meteo_fl" = "meteo_file.csv")
    nml <- glmtools::set_nml(nml, arg_list = nml_list)

    glmtools::write_nml(nml, nml_path)
    message("GLM: Created file ", file.path(folder, "GLM", "meteo_file.csv"))


  }

  ## GOTM
  if("GOTM" %in% model){

    yaml <- file.path(folder, get_yaml_value(config_file, "config_files", "GOTM"))

    met_outfile <- "meteo_file.dat"

    met_outfpath <- file.path(folder, "GOTM", met_outfile)

    got_met <- format_met(met, model = "GOTM", daily = daily, config_file = config_file)

    #Scale met
    if(!is.null(scale_param)){
      scale_met(got_met, pars = scale_param, model = "GOTM", out_file = met_outfpath)
    } else {
      # Write to file
      write.table(got_met, met_outfpath, quote = FALSE, row.names = FALSE, sep = "\t",
                  col.names = TRUE)
    }

    # Format gotm.yaml file
    ## Set gotm.yaml met config - helper function
    set_met_config_yaml(met = met_outfpath, yaml_file = yaml)

    message("GOTM: Created file ", file.path(folder, "GOTM", met_outfile))


  }

  ## Simstrat
  if("Simstrat" %in% model){

    met_outfile <- "meteo_file.dat"
    par_file <- file.path(folder, get_yaml_value(config_file, "config_files", "Simstrat"))

    met_outfpath <- file.path(folder, "Simstrat", met_outfile)
    
    sim_met <- format_met(met = met, model = "Simstrat", config_file = config_file, daily = daily)
    
    #Scale met
    if(!is.null(scale_param)){
      scale_met(sim_met, pars = scale_param, model = "Simstrat", out_file = met_outfpath)
    } else {
      # Write to file
      write.table(sim_met, met_outfpath, quote = FALSE, row.names = FALSE, sep = "\t",
                  col.names = TRUE)
    }

    ### Write the table in the present working directory
    input_json(file = par_file, label = "Input", key = "Forcing", "\"meteo_file.dat\"")

    message("Simstrat: Created file ", file.path(folder, "Simstrat", met_outfile))
  }

  ## MyLake
  if("MyLake" %in% model){

    met_outfile <- "meteo_file.dat"
    met_outfpath <- file.path(folder, "MyLake", met_outfile)
    mylake_met <- format_met(met = met, model = "MyLake", config_file = config_file, daily = daily)
    #Scale met
    if(!is.null(scale_param)){
      scale_met(mylake_met, pars = scale_param, model = "MyLake", out_file = met_outfpath)
      } else {
      # Write to file
      write.table(mylake_met, met_outfpath, quote = FALSE, row.names = FALSE, sep = "\t",
                  col.names = FALSE)
      }
      message("MyLake: Created file ", file.path(folder, "MyLake", met_outfile))
    }

    # Set the timezone back to the original
    Sys.setenv(TZ = original_tz)


}

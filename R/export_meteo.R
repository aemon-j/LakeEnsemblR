#' Export LakeEnsemblR standardized input to model specific driver format
#'
#'Export driver files for each model
#'
#' @param config_file filepath; to LakeEnsemblr yaml master config file
#' @param model vector; model to export driving data. Options include c('GOTM', 'GLM', 'Simstrat', 'FLake')
#' @param meteo_file filepath; to met file which is in the standardised LakeEnsemblR format. Uses
#' @param scale_param dataframe; with column names referring to standard names in LER. Scales meteorological value according to value in the column. Defaults to NULL.
#' @param folder filepath; to folder which contains the model folders generated by export_config()
#'
#' @examples
#' \dontrun{
#' export_meteo(model = c('GOTM', 'GLM', 'Simstrat', 'FLake'), meteo_file = 'LakeEnsemblR_meteo_standard.csv')
#' }
#' @importFrom gotmtools get_yaml_value calc_cc input_yaml
#' @importFrom glmtools read_nml set_nml write_nml
#' @importFrom zoo na.approx
#'
#' @export
export_meteo <- function(config_file, model = c('GOTM', 'GLM', 'Simstrat', 'FLake', 'MyLake'), meteo_file = NULL, scale_param = NULL, folder = '.'){

  # It's advisable to set timezone to GMT in order to avoid errors when reading time
  original_tz = Sys.getenv("TZ")
  Sys.setenv(TZ="GMT")

  # Set working directory
  oldwd <- getwd()

  # this way if the function exits for any reason, success or failure, these are reset:
  on.exit({
    setwd(oldwd)
    Sys.setenv(TZ=original_tz)
  })



  yaml = file.path(folder,config_file)

  meteo_file <- get_yaml_value(file = yaml, label = 'meteo', key = 'file')
  # Check if file exists
  if(!file.exists(meteo_file)){
    stop(meteo_file, ' does not exist. Check filepath in ', config_file)
  }

  ### Import data
  # I'd prefer to use a function that can read both comma and tab delimited. data.table::fread does this, but then it's data.table
  message('Loading met data...')
  if(is.null(meteo_file)){
    meteo_file <- get_yaml_value(file = yaml, label = 'meteo', key = 'meteo_file')
  }
  met = read.csv(file.path(folder, meteo_file), stringsAsFactors = F)
  met[,1] <- as.POSIXct(met[,1])
  # Check time step
  tstep <- diff(as.numeric(met[,1]))

  if((mean(tstep) - 86400)/86400 < -0.05){
    daily = FALSE
    subdaily = TRUE
  } else {
    daily = TRUE
    subdaily = FALSE
  }

  # Extract lat, lon, elev
  lat <- get_yaml_value(file = config_file, label = 'location', key = 'latitude')
  lon <- get_yaml_value(file = config_file, label = 'location', key = 'longitude')
  elev <- get_yaml_value(file = config_file, label = 'location', key = 'elevation')


  ### Naming conventions standard input
  # Depending on the setup of the standard config file, we can omit reading exact titles and read column numbers
  colname_time = "datetime"
  colname_wind_speed = "Ten_Meter_Elevation_Wind_Speed_meterPerSecond"
  colname_u_wind = "Uwind_meterPerSecond"
  colname_v_wind = "Vwind_meterPerSecond"
  colname_wind_direction = "Ten_Meter_Elevation_Wind_Direction_degree"
  colname_air_temperature = "Air_Temperature_celsius"
  colname_dewpoint_temperature = "Dewpoint_Temperature_celsius"
  colname_relative_humidity = "Relative_Humidity_percent"
  colname_solar_radiation = "Shortwave_Radiation_Downwelling_wattPerMeterSquared"
  colname_longwave_radiation = "Longwave_Radiation_Downwelling_wattPerMeterSquared"
  colname_surface_pressure = "Surface_Level_Barometric_Pressure_pascal"
  colname_precipitation = "Precipitation_meterPerSecond"
  colname_snow = "Snowfall_meterPerDay"
  colname_vapour_pressure = "Vapor_Pressure_milliBar"
  colname_cloud_cover = "Cloud_Cover_decimalFraction"

  ### Check what met data is available, as this determines what model forcing option to use (in the simstrat config file)
  datetime = colname_time %in% colnames(met)
  wind_speed = colname_wind_speed %in% colnames(met)
  u_wind = colname_u_wind %in% colnames(met)
  v_wind = colname_v_wind %in% colnames(met)
  wind_direction = colname_wind_direction %in% colnames(met)
  air_temperature = colname_air_temperature %in% colnames(met)
  dewpoint_temperature = colname_dewpoint_temperature %in% colnames(met)
  solar_radiation = colname_solar_radiation %in% colnames(met)
  vapour_pressure = colname_vapour_pressure %in% colnames(met)
  relative_humidity = colname_relative_humidity %in% colnames(met)
  longwave_radiation = colname_longwave_radiation %in% colnames(met)
  cloud_cover = colname_cloud_cover %in% colnames(met)
  # Availability of precipitation data only used for snow module
  precipitation = colname_precipitation %in% colnames(met)
  snowfall = colname_snow %in% colnames(met)
  heat_flux = FALSE

  # Calculate other required variables
  # Relative humidity
  if(!relative_humidity & air_temperature & dewpoint_temperature){
    # The function is in helpers.R the formula is from the weathermetrics package
    met[[colname_relative_humidity]] <- dewt2relh(met[[colname_dewpoint_temperature]], met[[colname_air_temperature]])
    if(is.na(sum(met[[colname_relative_humidity]]))){
      met[[colname_relative_humidity]] <- na.approx(met[[colname_relative_humidity]])
      message('Interpolated NAs')
    }
    relative_humidity <- TRUE
  }

  # Vapour pressure
  if(!vapour_pressure & relative_humidity){
    # Calculate vapour pressure as: relhum * saturated vapour pressure
    # Used formula for saturated vapour pressure from:
    # Woolway, R. I., Jones, I. D., Hamilton, D. P., Maberly, S. C., Muraoka, K., Read, J. S., . . . Winslow, L. A. (2015).
    # Automated calculation of surface energy fluxes with high-frequency lake buoy data.
    # Environmental Modelling & Software, 70, 191-198.

    met[[colname_vapour_pressure]]=met[[colname_relative_humidity]]/100 * 6.11 * exp(17.27 * met[[colname_air_temperature]] / (237.3 + met[[colname_air_temperature]]))
    vapour_pressure <- TRUE

  }

  # Cloud cover
  if(!cloud_cover){

    met[[colname_cloud_cover]] =  calc_cc(date = met$datetime,
                                          airt = met$Air_Temperature_celsius,
                                          relh = met$Relative_Humidity_percent,
                                          swr = met$Shortwave_Radiation_Downwelling_wattPerMeterSquared,
                                          lat = lat, lon = lon,
                                          elev = elev,
                                          daily = daily)
    cloud_cover <- TRUE

  }

  #Snowfall
  if(!snowfall){
    freez_ind <- which(met[[colname_air_temperature]] < 0)
    met[[colname_snow]] <- 0
    met[[colname_snow]][freez_ind] <- met[[colname_precipitation]][freez_ind]
    met[[colname_precipitation]][freez_ind] <- 0
    met[[colname_snow]] <- met[[colname_snow]] * 86400 # m s-1 to m d-1
    snowfall <- TRUE
  }
  # Precipitation
  # Precipitation needs to be in m h-1: 1 m s-1 = 3600 m h-1, or 1 m d-1 = 1/24 m h-1
  if(precipitation){
    met$`Precipitation_meterPerHour`=met[[colname_precipitation]]*3600
  }#else if(snowfall){
  #  met$`Precipitation_meterPerHour`=met[[colname_snow]]/24
  #}

  # Long-wave radiation
  if(!longwave_radiation & dewpoint_temperature){
    met[[colname_longwave_radiation]] <- calc_in_lwr(cc = met[[colname_cloud_cover]], airt = met[[colname_air_temperature]], dewt = met[[colname_dewpoint_temperature]])
  }else if(!longwave_radiation & !dewpoint_temperature & relative_humidity){
    met[[colname_longwave_radiation]] <- calc_in_lwr(cc = met[[colname_cloud_cover]], airt = met[[colname_air_temperature]], relh = met[[colname_relative_humidity]])
  }

  # wind speed
  if(!wind_speed & u_wind & v_wind){
    met[[colname_wind_speed]] <- sqrt(met[[colname_u_wind]]^2 + met[[colname_v_wind]]^2)
  }

  # wind direction
  if(!wind_direction & u_wind & v_wind){
    met[[colname_wind_direction]] = calc_windDir(met[[colname_u_wind]], met[[colname_v_wind]])
    wind_direction <- TRUE
  }

  # u and v wind vectors
  if(!u_wind & !v_wind & wind_speed & wind_direction){
    rads = met[[colname_wind_direction]]/180*pi
    met[[colname_u_wind]] = met[[colname_wind_speed]]*cos(rads)
    met[[colname_v_wind]] = met[[colname_wind_speed]]*sin(rads)
    u_wind <- TRUE
    v_wind <- TRUE
  }

  if(!u_wind & !v_wind & wind_speed & !wind_direction){
    met[[colname_u_wind]] = met[[colname_wind_speed]]
    met[[colname_v_wind]] = 0
    u_wind <- TRUE
    v_wind <- TRUE
  }




  # FLake
  #####
  if('FLake' %in% model){

    fla_met <- format_met(met = met, model = 'FLake', daily = daily, config_file = config_file)

    # Met output file name
    met_outfile <- 'all_meteo_file.dat'
    met_outfile <- file.path(folder, 'FLake', met_outfile)


    #Scale met
    if(!is.null(scale_param)){
      scale_met(fla_met, pars = scale_param, model = 'FLake', out_file = met_outfile)
    }else{
      # Write to file
      write.table(fla_met, met_outfile, sep = '\t', quote = FALSE, col.names = FALSE, row.names = FALSE)
    }


    # Input values to nml
    nml_file <- list.files(file.path(folder, 'FLake'))[grep('nml', list.files(file.path(folder, 'FLake')))]
    nml_file <- file.path(folder, 'FLake', nml_file)

    input_nml(nml_file, 'SIMULATION_PARAMS', 'time_step_number', nrow(fla_met))
    input_nml(nml_file, 'METEO', 'meteofile', paste0("'",met_outfile,"'"))

    message('FLake: Created file ', file.path(folder,"FLake", met_outfile))


  }

  # GLM
  #####
  if('GLM' %in% model){
    glm_met <- format_met(met = met, model = 'GLM', config_file = config_file, daily = daily)

    met_outfile <- file.path('GLM', 'meteo_file.csv')

    #Scale met
    if(!is.null(scale_param)){
      scale_met(glm_met, pars = scale_param, model = 'GLM', out_file = met_outfile)
    }else{
      # Write to file
      write.csv(glm_met, met_outfile, row.names = FALSE, quote = FALSE)
    }



    if("LongWave" %in% colnames(glm_met)){
      lw_type = 'LW_IN'
    }else{
      lw_type = 'LW_IN' ### Needs to be developed catch if no LW
    }


    # Input to nml file
    nml_path <- file.path(folder, get_yaml_value(config_file, "config_files", "glm"))
    nml <- glmtools::read_nml(nml_path)

    nml_list <- list('subdaily' = subdaily, 'lw_type' = lw_type, 'meteo_fl' = 'meteo_file.csv')
    nml <- glmtools::set_nml(nml, arg_list = nml_list)

    glmtools::write_nml(nml, nml_path)
    message('GLM: Created file ', file.path(folder,"GLM", 'meteo_file.csv'))


  }

  ## GOTM
  if('GOTM' %in% model){

    yaml = file.path(folder, get_yaml_value(config_file, "config_files", "gotm"))

    met_outfile <- 'meteo_file.dat'

    met_outfpath <- file.path(folder, 'GOTM', met_outfile)
    got_met <- format_met(met, model = 'GOTM', daily = daily, config_file = config_file)


    #Scale met
    if(!is.null(scale_param)){
      scale_met(got_met, pars = scale_param, model = 'GOTM', out_file = met_outfpath)
    }else{
      # Write to file
      write.table(got_met, met_outfpath, quote = FALSE, row.names = FALSE, sep = '\t', col.names = TRUE)
    }


    # Format gotm.yaml file
    ## Set gotm.yaml met config - helper function
    set_met_config_yaml(met = met_outfpath, yaml_file = yaml)

    message('GOTM: Created file ', file.path(folder,"GOTM", met_outfile))


  }

  ## Simstrat
  if('Simstrat' %in% model){

    met_outfile <- 'meteo_file.dat'
    par_file <- file.path(folder, get_yaml_value(config_file, "config_files", "simstrat"))

    met_outfpath <- file.path(folder,"Simstrat", met_outfile)



    sim_met <- format_met(met = met, model = 'Simstrat', config_file = config_file, daily = daily)

    #Scale met
    if(!is.null(scale_param)){
      scale_met(sim_met, pars = scale_param, model = 'Simstrat', out_file = met_outfpath)
    }else{
      # Write to file
      write.table(sim_met, met_outfpath, quote = FALSE, row.names = FALSE, sep = '\t', col.names = TRUE)
    }

    ### Write the table in the present working directory
    input_json(file = par_file, label = 'Input', key = 'Forcing', '"meteo_file.dat"')

    message('Simstrat: Created file ', file.path(folder,"Simstrat", met_outfile))
  }
  
  ## MyLake
  if('MyLake' %in% model){

    met_outfile <- 'meteo_file.dat'
    mylake_met <- met
    
    if(!solar_radiation){
      mylake_met$Shortwave_Radiation_Downwelling_wattPerMeterSquared <- 0
    }
    
    mylake_met <- mylake_met[,c(colname_time,
                                colname_solar_radiation,
                                colname_cloud_cover,
                                colname_air_temperature,
                                colname_relative_humidity,
                                colname_surface_pressure,
                                colname_wind_speed,
                                colname_precipitation)]
    
    # scale for units accepted in MyLake
    mylake_met$Shortwave_Radiation_Downwelling_wattPerMeterSquared <- mylake_met$Shortwave_Radiation_Downwelling_wattPerMeterSquared*0.0864
    mylake_met$Surface_Level_Barometric_Pressure_pascal <- mylake_met$Surface_Level_Barometric_Pressure_pascal*0.01
    mylake_met$Precipitation_meterPerSecond <- mylake_met$Precipitation_meterPerSecond*86400000
    mylake_met$datetime <- as.matrix(floor((as.numeric(as.POSIXct(mylake_met$datetime))/86400)+719529))

    # write met file for MyLake
    write.table(mylake_met, file.path(folder,'MyLake',met_outfile), col.names = FALSE,row.names = FALSE)
    
    message('MyLake: Created file ', file.path(folder,"MyLake", met_outfile))
  }
  
  # Set the timezone back to the original
  Sys.setenv(TZ=original_tz)


}
